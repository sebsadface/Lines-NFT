// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {Base64} from "@openzeppelin/contracts/utils/Base64.sol";
import {IVRFCoordinatorV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFCoordinatorV2Plus.sol";
import {VRFConsumerBaseV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import {VRFV2PlusClient} from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";
import {IP} from "@story-protocol/protocol-core/contracts/lib/IP.sol";
import {IPAssetRegistry} from "@story-protocol/protocol-core/contracts/registries/IPAssetRegistry.sol";
import {IPResolver} from "@story-protocol/protocol-core/contracts/resolvers/IPResolver.sol";

/**
 * @title Lines NFT Collection
 * @notice Lines NFT Collection comes with 10,000 randomly generated SVGs, each uniquely registered as intellectual property.
 * @dev Extends ERC721URIStorage for token URI storage, utilizes Chainlink VRF for provable randomness,
 * and registers minted tokens as intellectual property (IP) using Story Protocol's IPAssetRegistry.
 * This contract supports non-reentrant minting operations and ensures IP registration is handled seamlessly on mint.
 */
contract Lines is ERC721URIStorage, VRFConsumerBaseV2Plus, ReentrancyGuard {
    using Strings for uint256;

    /// @notice The IPResolver contract used for IP registration.
    IPResolver public immutable IP_RESOLVER;

    /// @notice The IPAssetRegistry contract used for IP registration.
    IPAssetRegistry public immutable IP_ASSET_REGISTRY;

    /// @notice The Chainlink VRF Coordinator contract used for randomness generation.
    IVRFCoordinatorV2Plus public immutable VRF_COORDINATOR;

    /// @notice Emitted when a new IP is registered in the IP Asset Registry.
    /// @param ipId The identifier for the newly registered IP.
    event IPRegistered(address ipId);

    /// @notice Emitted when a randomness request is sent to Chainlink VRF.
    /// @param requestId The identifier of the Chainlink VRF request.
    event RequestSent(uint256 requestId);

    /// @notice Emitted when a randomness request is fulfilled by Chainlink VRF.
    /// @param requestId The identifier of the fulfilled request.
    event RequestFulfilled(uint256 requestId);

    /// @notice Emitted when a new token is minted and associated IP is registered.
    /// @param tokenId The identifier for the newly minted token.
    /// @param ipId The address for the registered IP's token bounded account corresponding to the new token.
    event Minted(uint256 tokenId, address ipId);

    /// @dev Stores details of each VRF request associated with a minting operation.
    struct VRFRequest {
        bool fulfilled;
        ///< True if the minting request has been fulfilled
        bool exists;
        ///< True if the mint request exists
        uint256 randomness;
    }
    ///< Random number generated by Chainlink VRF, 0 if not fulfilled

    /// @dev Internal mapping of Chainlink VRF request IDs to VRFRequest structs.
    mapping(uint256 => VRFRequest) private requestIdToVRFRequest;

    /// @notice The maximum supply of Lines NFTs.
    uint256 public constant MAX_SUPPLY = 10 ** 4;

    /// @dev Default Chainlink VRF configuration parameters.
    uint32 private constant numWords = 1;
    ///< Number of random words to request
    uint16 private constant requestConfirmations = 3;
    ///< Number of confirmations to wait for
    uint32 private constant callbackGasLimit = 2500000;
    ///< Gas limit for the VRF callback

    /// @dev requestId of the last Chainlink VRF request, used to retrieve randomness for minting.
    uint256 private lastRequestId;

    /// @dev The ID of the next token to be minted, starting from 0, up to MAX_SUPPLY.
    uint256 private nextTokenId;

    /// @dev Chainlink VRF subscription ID.
    uint256 private chainlinkSubscriptionId;

    /// @dev Chainlink VRF 30 gwei Key Hash
    bytes32 private keyHash;

    /// @dev Flag to ensure only one randomness request is made to initialize the contract.
    bool public firstRandomnessRequested;

    constructor(
        address ipAssetRegistry,
        address resolver,
        address vrfCoordinator,
        uint256 _chainlinkSubscriptionId,
        bytes32 _keyHash
    ) ERC721("Lines", "LINE") VRFConsumerBaseV2Plus(vrfCoordinator) {
        VRF_COORDINATOR = IVRFCoordinatorV2Plus(vrfCoordinator);
        IP_RESOLVER = IPResolver(resolver);
        IP_ASSET_REGISTRY = IPAssetRegistry(ipAssetRegistry);

        nextTokenId = 0;
        keyHash = _keyHash;
        firstRandomnessRequested = false;
        chainlinkSubscriptionId = _chainlinkSubscriptionId;
    }

    /**
     * @notice Requests initial randomness from Chainlink VRF to start the minting process.
     * Call will revert if this function has already been called once, or if the caller is not the contract owner.
     * @dev Request randomness for the first minting operation in the contract.
     * Can only be called once by the contract owner to initialize randomness for the minting queue.
     * @return requestId The identifier of the Chainlink VRF request.
     */
    function requestFirstRandomness() external onlyOwner returns (uint256 requestId) {
        require(!firstRandomnessRequested, "Initialization Randomness already requested");

        requestId = _requestRandomness();

        firstRandomnessRequested = true;

        return requestId;
    }

    /**
     * @notice Generates and mints a new token, registers it as an IP, and requests randomness for the next minting operation.
     * This function only supports minting one token at a time, the following minting operation will need to wait for Chainlink VRF
     * call back to complete.
     * Call will revert if one of the following is true:
     * - The maximum supply of tokens has been reached.
     * - There is no randomness available to mint a new token
     *   (This can either be because requestFirstRandomness has not been called, or the previous Chainlink VRF request has not been fulfilled).
     * - The caller has not approved the contract to register IP on their behalf at the IPAssetRegistry.
     * @dev Since our NFT is completely stored on-chain, the SVG generation and IP registration process made
     * minting operations fairly expensive and exceeded Chainlink VRF's call back gas limit. To mitigate this, we split the
     * randomness generation into two parts. The first request (requestFirstRandomness) initializes the randomness for the next mint operation,
     * and the second request is made after the mint operation to ensure the randomness is available for the next mint.
     * Ensures all operations are non-reentrant.
     * @return tokenId The ID of the newly minted token and the IP address of the newly registered IP.
     */
    function requestMint() public nonReentrant returns (uint256, address) {
        // Ensure minting is not over the maximum supply
        require(nextTokenId < MAX_SUPPLY, "Sale has already ended");

        // Ensure randomness is available for minting
        require(lastRequestId != 0, "No randomness available, try again later");

        // Ensure the previous Chainlink VRF request has been fulfilled
        require(requestIdToVRFRequest[lastRequestId].fulfilled, "Previous randomness request not fulfilled");

        // Ensure the caller has approved the contract to register IP on their behalf
        require(
            IP_ASSET_REGISTRY.isApprovedForAll(msg.sender, address(this)),
            "Unable to mint, please delegate IP registration"
        );

        // Retrieve the randomness from the last fulfilled Chainlink VRF request
        uint256 randomness = requestIdToVRFRequest[lastRequestId].randomness;

        // Deplete the randomness, need to request new randomness
        lastRequestId = 0;

        // The address of the caller is the owner of this minted token
        address minter = msg.sender;

        uint256 tokenId = nextTokenId;

        // Generate the IP name format: "Line#<TOKENID>"
        string memory ipName = string(abi.encodePacked("Pattern#", Strings.toString(tokenId)));

        // This randomness hash is used as attribute in the token URI
        string memory randomnessHash = _bytesToHexString(keccak256(abi.encodePacked(randomness)));

        // Generate the SVG image based on the randomness
        string memory svg = _generateSVG(randomness);

        // Base64 encode the SVG and format it as a token URI
        string memory uri = _formatTokenURI(svg, randomnessHash);

        // This content has is used to fill in the IP metadata
        bytes32 contentHash = keccak256(abi.encodePacked(svg));

        // Mint the token and set the token URI
        _safeMint(minter, tokenId);
        _setTokenURI(tokenId, uri);
        nextTokenId++;

        // Register the IP at Story Protocol's IPAssetRegistry
        address ipId = _registerIp(tokenId, minter, contentHash, ipName, uri);

        // Request new randomness for the next minting operation
        // This function will update the lastRequestId
        _requestRandomness();

        emit Minted(tokenId, ipId);

        return (tokenId, ipId);
    }

    /**
     *
     * @dev Returns the total supply of the collection
     * @return the max supply of the collection
     */
    function totalSupply() public pure returns (uint256) {
        return MAX_SUPPLY;
    }

    // >>>>>>>>> Internal Functions <<<<<<<<<<<
    /**
     *
     * @dev Callback function called by Chainlink VRF Coordinator when randomness is generated.
     * This function updates the VRFRequest struct in the requestIdToVRFRequest mapping with the randomness generated by Chainlink VRF.
     * @param requestId The identifier of the Chainlink VRF request
     * @param randomWords The random number generated by Chainlink VRF (since we requested 1 word, we will only use the element at index 0)
     */
    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {
        require(requestIdToVRFRequest[requestId].exists, "request not found");

        requestIdToVRFRequest[requestId].randomness = randomWords[0];
        requestIdToVRFRequest[requestId].fulfilled = true;

        emit RequestFulfilled(requestId);
    }

    /**
     *
     * @dev Registers a new IP at the IPAssetRegistry contract, and emits an IPRegistered event.
     * This function registers the IP with the provided metadata and returns the IP's address.
     * This function is only called internally during the minting process, and it assumes
     * the caller has already approved the contract to register IP on their behalf.
     * @param tokenId The identifier of the token to be associated with the IP
     * @param registrant The owner of the token and thus the IP
     * @param contentHash The content hash of the IP
     * @param ipName The name of the IP
     * @param uri The URI of the IP
     * @return ipId The address of the token bounded account of the newly registered IP.
     */
    function _registerIp(
        uint256 tokenId,
        address registrant,
        bytes32 contentHash,
        string memory ipName,
        string memory uri
    ) internal returns (address) {
        bytes memory canonicalMetadata = abi.encode(
            IP.MetadataV1({
                name: ipName,
                hash: contentHash,
                registrationDate: uint64(block.timestamp),
                registrant: registrant,
                uri: uri
            })
        );

        address ipId = IP_ASSET_REGISTRY.register(
            block.chainid, address(this), tokenId, address(IP_RESOLVER), true, canonicalMetadata
        );

        emit IPRegistered(ipId);
        return ipId;
    }

    /**
     *
     * @dev Requests randomness from Chainlink VRF and stores the request details in the requestIdToVRFRequest mapping.
     * This function updates the lastRequestId with the identifier of the Chainlink VRF request.
     * This function is called by requestFirstRandomness and requestMint.
     * @return requestId The identifier of the Chainlink VRF request
     */
    function _requestRandomness() internal returns (uint256) {
        uint256 requestId = VRF_COORDINATOR.requestRandomWords(
            VRFV2PlusClient.RandomWordsRequest({
                keyHash: keyHash,
                subId: chainlinkSubscriptionId,
                requestConfirmations: requestConfirmations,
                callbackGasLimit: callbackGasLimit,
                numWords: numWords,
                extraArgs: VRFV2PlusClient._argsToBytes(VRFV2PlusClient.ExtraArgsV1({nativePayment: false}))
            })
        );

        requestIdToVRFRequest[requestId] = VRFRequest({fulfilled: false, exists: true, randomness: 0});

        lastRequestId = requestId;

        return requestId;
    }

    /**
     *
     * @dev Since we base64 encode the token URI, we need to set the base URI to "data:application/json;base64,"
     * so that it will be correctly rendered and parsed when queried.
     * @return baseURI The base URI for the token URI
     */
    function _baseURI() internal pure override returns (string memory) {
        return "data:application/json;base64,";
    }

    /**
     *
     * @dev Generates an SVG image based on provided randomness and formats it as a token URI.
     * The randomness is used to pick random colors and coordinates for the SVG lines.
     * This function is only called internally during the requestMint function.
     * @param randomness Random number used to define unique properties of the SVG.
     * @return svg A complete SVG image string.
     */
    function _generateSVG(uint256 randomness) internal pure returns (string memory) {
        string memory svg = '<svg xmlns="http://www.w3.org/2000/svg" width="800" height="800">';

        // Generate 10 random lines with random colors and coordinates
        for (uint256 i = 0; i < 10; i++) {
            // Generate a random color in the format "rgb(r,g,b)"
            bytes memory color = abi.encodePacked(
                "rgb(",
                ((randomness >> (i * 3)) % 255).toString(),
                ",",
                ((randomness >> (i * 6)) % 255).toString(),
                ",",
                ((randomness >> (i * 9)) % 255).toString(),
                ")"
            );

            // Generate random coordinates for the two endpoints of a line
            // e.g. (x1, y1) and (x2, y2)
            uint256 x1 = (randomness >> (i * 12)) % 800;
            uint256 y1 = (randomness >> (i * 15)) % 800;
            uint256 x2 = (randomness >> (i * 18)) % 800;
            uint256 y2 = (randomness >> (i * 21)) % 800;

            svg = string(
                abi.encodePacked(
                    svg,
                    '<line x1="',
                    x1.toString(),
                    '" y1="',
                    y1.toString(),
                    '" x2="',
                    x2.toString(),
                    '" y2="',
                    y2.toString(),
                    '" style="stroke:',
                    string(color),
                    ';stroke-width:2" />'
                )
            );
        }

        return string(abi.encodePacked(svg, "</svg>"));
    }

    /**
     *
     * @dev Formats the SVG image and json metadata as a base64 encoded string and constructs the token URI.
     * This function is only called internally inside the requestMint function.
     * @param svg The SVG image string generated by the _generateSVG function.
     * @param randomnessHash The hash of the randomness used to generate the SVG.
     * @return tokenURI The complete base64 encoded token URI string.
     */
    function _formatTokenURI(string memory svg, string memory randomnessHash) internal pure returns (string memory) {
        string memory base64SVG = Base64.encode(bytes(svg));
        string memory imageURI = string(abi.encodePacked("data:image/svg+xml;base64,", base64SVG));

        string memory json = Base64.encode(
            bytes(
                string(
                    abi.encodePacked(
                        '{"name": "Line", ',
                        '"description": "This piece is a cryptic dance of lines and colors, captured at the intersection of chance and destiny. As unique as the blockchain itself, these digital tapestries weave together the mysterious elegance of algorithmic randomness. Journey through an evolving gallery of ethereal art, where every piece holds a story waiting to be discovered.", ',
                        '"image": "',
                        imageURI,
                        '", ',
                        '"attributes":[{"trait_type": "Randomness", ',
                        '"value": "',
                        randomnessHash,
                        '"}]}'
                    )
                )
            )
        );

        return string(abi.encodePacked(json));
    }

    /**
     *
     * @dev Utility function used to convert a bytes32 buffer to a hexadecimal string.
     * This function is only called internally inside the requestMint function to convert the randomness hash to a hex string.
     * @param buf The bytes32 buffer to convert to a hexadecimal string.
     * @return converted The hexadecimal string representation of the bytes32 buffer.
     */
    function _bytesToHexString(bytes32 buf) internal pure returns (string memory) {
        bytes memory converted = new bytes(buf.length * 2);

        bytes memory _base = "0123456789abcdef";

        for (uint256 i = 0; i < buf.length; i++) {
            converted[i * 2] = _base[uint8(buf[i]) / _base.length];
            converted[i * 2 + 1] = _base[uint8(buf[i]) % _base.length];
        }

        return string(abi.encodePacked("0x", converted));
    }

    // >>>>>>>>> required overrides <<<<<<<<<<<
    function tokenURI(uint256 tokenId) public view override(ERC721URIStorage) returns (string memory) {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId) public view override(ERC721URIStorage) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}
