{"language":"Solidity","sources":{"contracts/Lines.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Base64} from \"@openzeppelin/contracts/utils/Base64.sol\";\nimport {IVRFCoordinatorV2Plus} from \"@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFCoordinatorV2Plus.sol\";\nimport {VRFConsumerBaseV2Plus} from \"@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol\";\nimport {VRFV2PlusClient} from \"@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol\";\nimport {IP} from \"@story-protocol/protocol-core/contracts/lib/IP.sol\";\nimport {IPAssetRegistry} from \"@story-protocol/protocol-core/contracts/registries/IPAssetRegistry.sol\";\nimport {IPResolver} from \"@story-protocol/protocol-core/contracts/resolvers/IPResolver.sol\";\n\n/**\n * @title Lines NFT Collection\n * @notice Lines NFT Collection comes with 10,000 randomly generated SVGs, each uniquely registered as intellectual property.\n * @dev Extends ERC721URIStorage for token URI storage, utilizes Chainlink VRF for provable randomness,\n * and registers minted tokens as intellectual property (IP) using Story Protocol's IPAssetRegistry.\n * This contract supports non-reentrant minting operations and ensures IP registration is handled seamlessly on mint.\n */\ncontract Lines is ERC721URIStorage, VRFConsumerBaseV2Plus, ReentrancyGuard {\n    using Strings for uint256;\n\n    /// @notice The IPResolver contract used for IP registration.\n    IPResolver public immutable IP_RESOLVER;\n\n    /// @notice The IPAssetRegistry contract used for IP registration.\n    IPAssetRegistry public immutable IP_ASSET_REGISTRY;\n\n    /// @notice The Chainlink VRF Coordinator contract used for randomness generation.\n    IVRFCoordinatorV2Plus public immutable VRF_COORDINATOR;\n\n    /// @notice Emitted when a new IP is registered in the IP Asset Registry.\n    /// @param ipId The identifier for the newly registered IP.\n    event IPRegistered(address ipId);\n\n    /// @notice Emitted when a randomness request is sent to Chainlink VRF.\n    /// @param requestId The identifier of the Chainlink VRF request.\n    event RequestSent(uint256 requestId);\n\n    /// @notice Emitted when a randomness request is fulfilled by Chainlink VRF.\n    /// @param requestId The identifier of the fulfilled request.\n    event RequestFulfilled(uint256 requestId);\n\n    /// @notice Emitted when a new token is minted and associated IP is registered.\n    /// @param tokenId The identifier for the newly minted token.\n    /// @param ipId The address for the registered IP's token bounded account corresponding to the new token.\n    event Minted(uint256 tokenId, address ipId);\n\n    /// @dev Stores details of each VRF request associated with a minting operation.\n    struct VRFRequest {\n        bool fulfilled; ///< True if the minting request has been fulfilled\n        bool exists; ///< True if the mint request exists\n        uint256 randomness; ///< Random number generated by Chainlink VRF, 0 if not fulfilled\n    }\n\n    /// @dev Internal mapping of Chainlink VRF request IDs to VRFRequest structs.\n    mapping(uint256 => VRFRequest) private requestIdToVRFRequest;\n\n    /// @notice The maximum supply of Lines NFTs.\n    uint256 public constant MAX_SUPPLY = 10 ** 4;\n\n    /// @dev Default Chainlink VRF configuration parameters.\n    uint32 private constant numWords = 1; ///< Number of random words to request\n    uint16 private constant requestConfirmations = 3; ///< Number of confirmations to wait for\n    uint32 private constant callbackGasLimit = 2500000; ///< Gas limit for the VRF callback\n\n    /// @dev requestId of the last Chainlink VRF request, used to retrieve randomness for minting.\n    uint256 private lastRequestId;\n\n    /// @dev The ID of the next token to be minted, starting from 0, up to MAX_SUPPLY.\n    uint256 private nextTokenId;\n\n    /// @dev Chainlink VRF subscription ID.\n    uint256 private chainlinkSubscriptionId;\n\n    /// @dev Chainlink VRF 30 gwei Key Hash\n    bytes32 private keyHash;\n\n    /// @dev Flag to ensure only one randomness request is made to initialize the contract.\n    bool public firstRandomnessRequested;\n\n    constructor(\n        address ipAssetRegistry,\n        address resolver,\n        address vrfCoordinator,\n        uint256 _chainlinkSubscriptionId,\n        bytes32 _keyHash\n    ) ERC721(\"Lines\", \"LINE\") VRFConsumerBaseV2Plus(vrfCoordinator) {\n        VRF_COORDINATOR = IVRFCoordinatorV2Plus(vrfCoordinator);\n        IP_RESOLVER = IPResolver(resolver);\n        IP_ASSET_REGISTRY = IPAssetRegistry(ipAssetRegistry);\n\n        nextTokenId = 0;\n        keyHash = _keyHash;\n        firstRandomnessRequested = false;\n        chainlinkSubscriptionId = _chainlinkSubscriptionId;\n    }\n\n    /**\n     * @notice Requests initial randomness from Chainlink VRF to start the minting process.\n     * Call will revert if this function has already been called once.\n     * @dev Request randomness for the first minting operation in the contract.\n     * Can only be called once by the contract owner to initialize randomness for the minting queue.\n     * @return requestId The identifier of the Chainlink VRF request.\n     */\n    function requestFirstRandomness()\n        external\n        onlyOwner\n        returns (uint256 requestId)\n    {\n        require(\n            !firstRandomnessRequested,\n            \"Initialization Randomness already requested\"\n        );\n\n        requestId = _requestRandomness();\n\n        firstRandomnessRequested = true;\n\n        return requestId;\n    }\n\n    /**\n     * @notice Generates and mints a new token, registers it as an IP, and requests randomness for the next minting operation.\n     * This function only supports minting one token at a time, the following minting operation will need to wait for Chainlink VRF\n     * call back to complete.\n     * Call will revert if one of the following is true:\n     * - The maximum supply of tokens has been reached.\n     * - There is no randomness available to mint a new token\n     *   (This can either be because requestFirstRandomness has not been called, or the previous Chainlink VRF request has not been fulfilled).\n     * - The caller has not approved the contract to register IP on their behalf at the IPAssetRegistry.\n     * @dev Since our NFT is completely stored on-chain, the SVG generation and IP registration process made\n     * minting operations fairly expensive and exceeded Chainlink VRF's call back gas limit. To mitigate this, we split the\n     * randomness generation into two parts. The first request (requestFirstRandomness) initializes the randomness for the next mint operation,\n     * and the second request is made after the mint operation to ensure the randomness is available for the next mint.\n     * Ensures all operations are non-reentrant.\n     * @return tokenId The ID of the newly minted token and the IP address of the newly registered IP.\n     */\n    function requestMint() public nonReentrant returns (uint256, address) {\n        // Ensure minting is not over the maximum supply\n        require(nextTokenId < MAX_SUPPLY, \"Sale has already ended\");\n\n        // Ensure randomness is available for minting\n        require(lastRequestId != 0, \"No randomness available, try again later\");\n\n        // Ensure the previous Chainlink VRF request has been fulfilled\n        require(\n            requestIdToVRFRequest[lastRequestId].fulfilled,\n            \"Previous randomness request not fulfilled\"\n        );\n\n        // Ensure the caller has approved the contract to register IP on their behalf\n        require(\n            IP_ASSET_REGISTRY.isApprovedForAll(msg.sender, address(this)),\n            \"Unable to mint, please delegate IP registration\"\n        );\n\n        // Retrieve the randomness from the last fulfilled Chainlink VRF request\n        uint256 randomness = requestIdToVRFRequest[lastRequestId].randomness;\n\n        // Deplete the randomness, need to request new randomness\n        lastRequestId = 0;\n\n        // The address of the caller is the owner of this minted token\n        address minter = msg.sender;\n\n        uint256 tokenId = nextTokenId;\n\n        // Generate the IP name format: \"Line#<TOKENID>\"\n        string memory ipName = string(\n            abi.encodePacked(\"Pattern#\", Strings.toString(tokenId))\n        );\n\n        // This randomness hash is used as attribute in the token URI\n        string memory randomnessHash = _bytesToHexString(\n            keccak256(abi.encodePacked(randomness))\n        );\n\n        // Generate the SVG image based on the randomness\n        string memory svg = _generateSVG(randomness);\n\n        // Base64 encode the SVG and format it as a token URI\n        string memory uri = _formatTokenURI(svg, randomnessHash);\n\n        // This content has is used to fill in the IP metadata\n        bytes32 contentHash = keccak256(abi.encodePacked(svg));\n\n        // Mint the token and set the token URI\n        _safeMint(minter, tokenId);\n        _setTokenURI(tokenId, uri);\n        nextTokenId++;\n\n        // Register the IP at Story Protocol's IPAssetRegistry\n        address ipId = _registerIp(tokenId, minter, contentHash, ipName, uri);\n\n        // Request new randomness for the next minting operation\n        // This function will update the lastRequestId\n        _requestRandomness();\n\n        emit Minted(tokenId, ipId);\n\n        return (tokenId, ipId);\n    }\n\n    /***\n     * @dev Returns the total supply of the collection\n     * @return the max supply of the collection\n     */\n    function totalSupply() public pure returns (uint256) {\n        return MAX_SUPPLY;\n    }\n\n    // >>>>>>>>> Internal Functions <<<<<<<<<<<\n    /***\n     * @dev Callback function called by Chainlink VRF Coordinator when randomness is generated.\n     * This function updates the VRFRequest struct in the requestIdToVRFRequest mapping with the randomness generated by Chainlink VRF.\n     * @param requestId The identifier of the Chainlink VRF request\n     * @param randomWords The random number generated by Chainlink VRF (since we requested 1 word, we will only use the element at index 0)\n     */\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) internal override {\n        require(requestIdToVRFRequest[requestId].exists, \"request not found\");\n\n        requestIdToVRFRequest[requestId].randomness = randomWords[0];\n        requestIdToVRFRequest[requestId].fulfilled = true;\n\n        emit RequestFulfilled(requestId);\n    }\n\n    /***\n     * @dev Registers a new IP at the IPAssetRegistry contract, and emits an IPRegistered event.\n     * This function registers the IP with the provided metadata and returns the IP's address.\n     * This function is only called internally during the minting process, and it assumes\n     * the caller has already approved the contract to register IP on their behalf.\n     * @param tokenId The identifier of the token to be associated with the IP\n     * @param registrant The owner of the token and thus the IP\n     * @param contentHash The content hash of the IP\n     * @param ipName The name of the IP\n     * @param uri The URI of the IP\n     * @return ipId The address of the token bounded account of the newly registered IP.\n     */\n    function _registerIp(\n        uint256 tokenId,\n        address registrant,\n        bytes32 contentHash,\n        string memory ipName,\n        string memory uri\n    ) internal returns (address) {\n        bytes memory canonicalMetadata = abi.encode(\n            IP.MetadataV1({\n                name: ipName,\n                hash: contentHash,\n                registrationDate: uint64(block.timestamp),\n                registrant: registrant,\n                uri: uri\n            })\n        );\n\n        address ipId = IP_ASSET_REGISTRY.register(\n            block.chainid,\n            address(this),\n            tokenId,\n            address(IP_RESOLVER),\n            true,\n            canonicalMetadata\n        );\n\n        emit IPRegistered(ipId);\n        return ipId;\n    }\n\n    /***\n     * @dev Requests randomness from Chainlink VRF and stores the request details in the requestIdToVRFRequest mapping.\n     * This function updates the lastRequestId with the identifier of the Chainlink VRF request.\n     * This function is called by requestFirstRandomness and requestMint.\n     * @return requestId The identifier of the Chainlink VRF request\n     */\n    function _requestRandomness() internal returns (uint256) {\n        uint256 requestId = VRF_COORDINATOR.requestRandomWords(\n            VRFV2PlusClient.RandomWordsRequest({\n                keyHash: keyHash,\n                subId: chainlinkSubscriptionId,\n                requestConfirmations: requestConfirmations,\n                callbackGasLimit: callbackGasLimit,\n                numWords: numWords,\n                extraArgs: VRFV2PlusClient._argsToBytes(\n                    VRFV2PlusClient.ExtraArgsV1({nativePayment: false})\n                )\n            })\n        );\n\n        requestIdToVRFRequest[requestId] = VRFRequest({\n            fulfilled: false,\n            exists: true,\n            randomness: 0\n        });\n\n        lastRequestId = requestId;\n\n        return requestId;\n    }\n\n    /***\n     * @dev Since we base64 encode the token URI, we need to set the base URI to \"data:application/json;base64,\"\n     * so that it will be correctly rendered and parsed when queried.\n     * @return baseURI The base URI for the token URI\n     */\n    function _baseURI() internal pure override returns (string memory) {\n        return \"data:application/json;base64,\";\n    }\n\n    /***\n     * @dev Generates an SVG image based on provided randomness and formats it as a token URI.\n     * The randomness is used to pick random colors and coordinates for the SVG lines.\n     * This function is only called internally during the requestMint function.\n     * @param randomness Random number used to define unique properties of the SVG.\n     * @return svg A complete SVG image string.\n     */\n    function _generateSVG(\n        uint256 randomness\n    ) internal pure returns (string memory) {\n        string\n            memory svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"800\" height=\"800\">';\n\n        // Generate 10 random lines with random colors and coordinates\n        for (uint256 i = 0; i < 10; i++) {\n            // Generate a random color in the format \"rgb(r,g,b)\"\n            bytes memory color = abi.encodePacked(\n                \"rgb(\",\n                ((randomness >> (i * 3)) % 255).toString(),\n                \",\",\n                ((randomness >> (i * 6)) % 255).toString(),\n                \",\",\n                ((randomness >> (i * 9)) % 255).toString(),\n                \")\"\n            );\n\n            // Generate random coordinates for the two endpoints of a line\n            // e.g. (x1, y1) and (x2, y2)\n            uint256 x1 = (randomness >> (i * 12)) % 800;\n            uint256 y1 = (randomness >> (i * 15)) % 800;\n            uint256 x2 = (randomness >> (i * 18)) % 800;\n            uint256 y2 = (randomness >> (i * 21)) % 800;\n\n            svg = string(\n                abi.encodePacked(\n                    svg,\n                    '<line x1=\"',\n                    x1.toString(),\n                    '\" y1=\"',\n                    y1.toString(),\n                    '\" x2=\"',\n                    x2.toString(),\n                    '\" y2=\"',\n                    y2.toString(),\n                    '\" style=\"stroke:',\n                    string(color),\n                    ';stroke-width:2\" />'\n                )\n            );\n        }\n\n        return string(abi.encodePacked(svg, \"</svg>\"));\n    }\n\n    /***\n     * @dev Formats the SVG image and json metadata as a base64 encoded string and constructs the token URI.\n     * This function is only called internally inside the requestMint function.\n     * @param svg The SVG image string generated by the _generateSVG function.\n     * @param randomnessHash The hash of the randomness used to generate the SVG.\n     * @return tokenURI The complete base64 encoded token URI string.\n     */\n    function _formatTokenURI(\n        string memory svg,\n        string memory randomnessHash\n    ) internal pure returns (string memory) {\n        string memory base64SVG = Base64.encode(bytes(svg));\n        string memory imageURI = string(\n            abi.encodePacked(\"data:image/svg+xml;base64,\", base64SVG)\n        );\n\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"name\": \"Line\", ',\n                        '\"description\": \"This piece is a cryptic dance of lines and colors, captured at the intersection of chance and destiny. As unique as the blockchain itself, these digital tapestries weave together the mysterious elegance of algorithmic randomness. Journey through an evolving gallery of ethereal art, where every piece holds a story waiting to be discovered.\", ',\n                        '\"image\": \"',\n                        imageURI,\n                        '\", ',\n                        '\"attributes\":[{\"trait_type\": \"Randomness\", ',\n                        '\"value\": \"',\n                        randomnessHash,\n                        '\"}]}'\n                    )\n                )\n            )\n        );\n\n        return string(abi.encodePacked(json));\n    }\n\n    /***\n     * @dev Utility function used to convert a bytes32 buffer to a hexadecimal string.\n     * This function is only called internally inside the requestMint function to convert the randomness hash to a hex string.\n     * @param buf The bytes32 buffer to convert to a hexadecimal string.\n     * @return converted The hexadecimal string representation of the bytes32 buffer.\n     */\n    function _bytesToHexString(\n        bytes32 buf\n    ) internal pure returns (string memory) {\n        bytes memory converted = new bytes(buf.length * 2);\n\n        bytes memory _base = \"0123456789abcdef\";\n\n        for (uint256 i = 0; i < buf.length; i++) {\n            converted[i * 2] = _base[uint8(buf[i]) / _base.length];\n            converted[i * 2 + 1] = _base[uint8(buf[i]) % _base.length];\n        }\n\n        return string(abi.encodePacked(\"0x\", converted));\n    }\n\n    // >>>>>>>>> required overrides <<<<<<<<<<<\n    function tokenURI(\n        uint256 tokenId\n    ) public view override(ERC721URIStorage) returns (string memory) {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view override(ERC721URIStorage) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"},"@story-protocol/protocol-core/contracts/resolvers/IPResolver.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { ResolverBase } from \"./ResolverBase.sol\";\nimport { KeyValueResolver } from \"../resolvers/KeyValueResolver.sol\";\nimport { IP_RESOLVER_MODULE_KEY } from \"../lib/modules/Module.sol\";\n\n/// @title IP Resolver\n/// @notice Canonical IP resolver contract used for Story Protocol.\n/// TODO: Add support for interface resolvers, where one can add a contract\n///        and supported interface (address, interfaceId) to tie to an IP asset.\n/// TODO: Add support for multicall, so multiple records may be set at once.\ncontract IPResolver is KeyValueResolver {\n    string public constant override name = IP_RESOLVER_MODULE_KEY;\n\n    constructor(address accessController, address ipAssetRegistry) ResolverBase(accessController, ipAssetRegistry) {}\n\n    /// @notice IERC165 interface support.\n    function supportsInterface(bytes4 id) public view virtual override returns (bool) {\n        return super.supportsInterface(id);\n    }\n}\n"},"@story-protocol/protocol-core/contracts/registries/IPAssetRegistry.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport { IIPAccount } from \"../interfaces/IIPAccount.sol\";\nimport { IIPAssetRegistry } from \"../interfaces/registries/IIPAssetRegistry.sol\";\nimport { IPAccountRegistry } from \"../registries/IPAccountRegistry.sol\";\nimport { IMetadataProviderMigratable } from \"../interfaces/registries/metadata/IMetadataProviderMigratable.sol\";\nimport { MetadataProviderV1 } from \"../registries/metadata/MetadataProviderV1.sol\";\nimport { Errors } from \"../lib/Errors.sol\";\nimport { IResolver } from \"../interfaces/resolvers/IResolver.sol\";\nimport { LICENSING_MODULE_KEY } from \"../lib/modules/Module.sol\";\nimport { IModuleRegistry } from \"../interfaces/registries/IModuleRegistry.sol\";\nimport { ILicensingModule } from \"../interfaces/modules/licensing/ILicensingModule.sol\";\nimport { IIPAssetRegistry } from \"../interfaces/registries/IIPAssetRegistry.sol\";\nimport { IRegistrationModule } from \"../interfaces/modules/IRegistrationModule.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\n\n/// @title IP Asset Registry\n/// @notice This contract acts as the source of truth for all IP registered in\n///         Story Protocol. An IP is identified by its contract address, token\n///         id, and coin type, meaning any NFT may be conceptualized as an IP.\n///         Once an IP is registered into the protocol, a corresponding IP\n///         asset is generated, which references an IP resolver for metadata\n///         attribution and an IP account for protocol authorization.\n///         IMPORTANT: The IP account address, besides being used for protocol\n///                    auth, is also the canonical IP identifier for the IP NFT.\ncontract IPAssetRegistry is IIPAssetRegistry, IPAccountRegistry, Governable {\n    /// @notice The canonical module registry used by the protocol.\n    IModuleRegistry public immutable MODULE_REGISTRY;\n\n    /// @notice The registration module that interacts with IPAssetRegistry.\n    IRegistrationModule public REGISTRATION_MODULE;\n\n    /// @notice Tracks the total number of IP assets in existence.\n    uint256 public totalSupply = 0;\n\n    /// @notice Checks whether an operator is approved to register on behalf of an IP owner.\n    mapping(address owner => mapping(address operator => bool)) public isApprovedForAll;\n\n    /// @dev Maps an IP, identified by its IP ID, to an IP record.\n    mapping(address => Record) internal _records;\n\n    /// @dev Tracks the current metadata provider used for IP registrations.\n    IMetadataProviderMigratable internal _metadataProvider;\n\n    /// TODO: Utilize module registry for fetching different modules.\n    constructor(\n        address erc6551Registry,\n        address ipAccountImpl,\n        address moduleRegistry,\n        address governance\n    ) IPAccountRegistry(erc6551Registry, ipAccountImpl) Governable(governance) {\n        MODULE_REGISTRY = IModuleRegistry(moduleRegistry);\n        _metadataProvider = IMetadataProviderMigratable(new MetadataProviderV1(address(this)));\n    }\n\n    // TODO: Switch to access controller for centralizing this auth mechanism.\n    /// @notice Enables third party operators to register on behalf of an NFT owner.\n    /// @param operator The address of the operator the sender authorizes.\n    /// @param approved Whether or not to approve that operator for registration.\n    function setApprovalForAll(address operator, bool approved) external {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @dev Sets the registration module that interacts with IPAssetRegistry.\n    /// @param registrationModule The address of the registration module.\n    function setRegistrationModule(address registrationModule) external onlyProtocolAdmin {\n        REGISTRATION_MODULE = IRegistrationModule(registrationModule);\n    }\n\n    /// @dev Sets the provider for storage of new IP metadata, while enabling existing IP assets to migrate their\n    /// metadata to the new provider.\n    /// @param newMetadataProvider Address of the new metadata provider contract.\n    function setMetadataProvider(address newMetadataProvider) external onlyProtocolAdmin {\n        _metadataProvider.setUpgradeProvider(newMetadataProvider);\n        _metadataProvider = IMetadataProviderMigratable(newMetadataProvider);\n    }\n\n    /// @notice Registers an NFT as IP, creating a corresponding IP record.\n    /// @param chainId The chain identifier of where the NFT resides.\n    /// @param tokenContract The address of the NFT.\n    /// @param tokenId The token identifier of the NFT.\n    /// @param resolverAddr The address of the resolver to associate with the IP.\n    /// @param createAccount Whether to create an IP account when registering.\n    /// @param metadata_ Metadata in bytes to associate with the IP.\n    /// @return ipId_ The address of the newly registered IP.\n    function register(\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId,\n        address resolverAddr,\n        bool createAccount,\n        bytes calldata metadata_\n    ) external returns (address ipId_) {\n        ipId_ = _register(\n            new uint256[](0),\n            \"\",\n            chainId,\n            tokenContract,\n            tokenId,\n            resolverAddr,\n            createAccount,\n            metadata_\n        );\n        emit IPRegistered(ipId_, chainId, tokenContract, tokenId, resolverAddr, address(_metadataProvider), metadata_);\n    }\n\n    /// @notice Registers an NFT as an IP using licenses derived from parent IP asset(s).\n    /// @param licenseIds The parent IP asset licenses used to derive the new IP asset.\n    /// @param royaltyContext The context for the royalty module to process.\n    /// @param chainId The chain identifier of where the NFT resides.\n    /// @param tokenContract The address of the NFT.\n    /// @param tokenId The token identifier of the NFT.\n    /// @param resolverAddr The address of the resolver to associate with the IP.\n    /// @param createAccount Whether to create an IP account when registering.\n    /// @param metadata_ Metadata in bytes to associate with the IP.\n    /// @return ipId_ The address of the newly registered IP.\n    function register(\n        uint256[] calldata licenseIds,\n        bytes calldata royaltyContext,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId,\n        address resolverAddr,\n        bool createAccount,\n        bytes calldata metadata_\n    ) external returns (address ipId_) {\n        ipId_ = _register(\n            licenseIds,\n            royaltyContext,\n            chainId,\n            tokenContract,\n            tokenId,\n            resolverAddr,\n            createAccount,\n            metadata_\n        );\n        emit IPRegistered(ipId_, chainId, tokenContract, tokenId, resolverAddr, address(_metadataProvider), metadata_);\n    }\n\n    /// @notice Gets the canonical IP identifier associated with an IP NFT.\n    /// @dev This is equivalent to the address of its bound IP account.\n    /// @param chainId The chain identifier of where the IP resides.\n    /// @param tokenContract The address of the IP.\n    /// @param tokenId The token identifier of the IP.\n    /// @return ipId The IP's canonical address identifier.\n    function ipId(uint256 chainId, address tokenContract, uint256 tokenId) public view returns (address) {\n        return super.ipAccount(chainId, tokenContract, tokenId);\n    }\n\n    /// @notice Checks whether an IP was registered based on its ID.\n    /// @param id The canonical identifier for the IP.\n    /// @return isRegistered Whether the IP was registered into the protocol.\n    function isRegistered(address id) external view returns (bool) {\n        return _records[id].resolver != address(0);\n    }\n\n    /// @notice Gets the resolver bound to an IP based on its ID.\n    /// @param id The canonical identifier for the IP.\n    /// @return resolver The IP resolver address if registered, else the zero address.\n    function resolver(address id) external view returns (address) {\n        return _records[id].resolver;\n    }\n\n    /// @notice Gets the metadata provider used for new metadata registrations.\n    /// @return metadataProvider The address of the metadata provider used for new IP registrations.\n    function metadataProvider() external view returns (address) {\n        return address(_metadataProvider);\n    }\n\n    /// @notice Gets the metadata provider linked to an IP based on its ID.\n    /// @param id The canonical identifier for the IP.\n    /// @return metadataProvider The metadata provider that was bound to this IP at creation time.\n    function metadataProvider(address id) external view returns (address) {\n        return address(_records[id].metadataProvider);\n    }\n\n    /// @notice Gets the underlying canonical metadata linked to an IP asset.\n    /// @param id The canonical ID of the IP asset.\n    /// @return metadata The metadata that was bound to this IP at creation time.\n    function metadata(address id) external view returns (bytes memory) {\n        if (address(_records[id].metadataProvider) == address(0)) {\n            revert Errors.IPAssetRegistry__NotYetRegistered();\n        }\n        return _records[id].metadataProvider.getMetadata(id);\n    }\n\n    /// @notice Sets the underlying metadata for an IP asset.\n    /// @dev As metadata is immutable but additive, this will only be used when an IP migrates from a new provider that\n    /// introduces new attributes.\n    /// @param id The canonical ID of the IP.\n    /// @param data Canonical metadata to associate with the IP.\n    function setMetadata(address id, address provider, bytes calldata data) external {\n        // Canonical metadata is set on registration and immutable thereafter, with new\n        // fields only added during a migration to new protocol-approved metadata provider.\n        if (address(_records[id].metadataProvider) != msg.sender) {\n            revert Errors.IPAssetRegistry__Unauthorized();\n        }\n        _setMetadata(id, IMetadataProviderMigratable(provider), data);\n    }\n\n    /// @notice Sets the resolver for an IP based on its canonical ID.\n    /// @param id The canonical ID of the IP.\n    /// @param resolverAddr The address of the resolver being set.\n    function setResolver(address id, address resolverAddr) public {\n        if (_records[id].resolver == address(0)) {\n            revert Errors.IPAssetRegistry__NotYetRegistered();\n        }\n        // TODO: Update authorization logic to use the access controller.\n        address owner = IIPAccount(payable(id)).owner();\n        if (msg.sender != owner && !isApprovedForAll[owner][msg.sender]) {\n            revert Errors.IPAssetRegistry__Unauthorized();\n        }\n        _setResolver(id, resolverAddr);\n    }\n\n    /// @dev Registers an NFT as an IP.\n    /// @param licenseIds IP asset licenses used to derive the new IP asset, if any.\n    /// @param royaltyContext The context for the royalty module to process.\n    /// @param chainId The chain identifier of where the NFT resides.\n    /// @param tokenContract The address of the NFT.\n    /// @param tokenId The token identifier of the NFT.\n    /// @param resolverAddr The address of the resolver to associate with the IP.\n    /// @param createAccount Whether to create an IP account when registering.\n    /// @param data Canonical metadata to associate with the IP.\n    function _register(\n        uint256[] memory licenseIds,\n        bytes memory royaltyContext,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId,\n        address resolverAddr,\n        bool createAccount,\n        bytes calldata data\n    ) internal returns (address id) {\n        id = ipId(chainId, tokenContract, tokenId);\n        if (_records[id].resolver != address(0)) {\n            revert Errors.IPAssetRegistry__AlreadyRegistered();\n        }\n\n        address _owner = IERC721(tokenContract).ownerOf(tokenId);\n        if (\n            msg.sender != _owner && msg.sender != address(REGISTRATION_MODULE) && !isApprovedForAll[_owner][msg.sender]\n        ) {\n            revert Errors.IPAssetRegistry__RegistrantUnauthorized();\n        }\n\n        if (id.code.length == 0 && createAccount && id != registerIpAccount(chainId, tokenContract, tokenId)) {\n            revert Errors.IPAssetRegistry__InvalidAccount();\n        }\n        _setResolver(id, resolverAddr);\n        _setMetadata(id, _metadataProvider, data);\n        totalSupply++;\n\n        if (licenseIds.length != 0) {\n            ILicensingModule licensingModule = ILicensingModule(MODULE_REGISTRY.getModule(LICENSING_MODULE_KEY));\n            licensingModule.linkIpToParents(licenseIds, id, royaltyContext);\n        }\n    }\n\n    /// @dev Sets the resolver for the specified IP.\n    /// @param id The canonical ID of the IP.\n    /// @param resolverAddr The address of the resolver being set.\n    function _setResolver(address id, address resolverAddr) internal {\n        ERC165Checker.supportsInterface(resolverAddr, type(IResolver).interfaceId);\n        _records[id].resolver = resolverAddr;\n        emit IPResolverSet(id, resolverAddr);\n    }\n\n    /// @dev Sets the for the specified IP asset.\n    /// @param id The canonical identifier for the specified IP asset.\n    /// @param provider The metadata provider hosting the data.\n    /// @param data The metadata to set for the IP asset.\n    function _setMetadata(address id, IMetadataProviderMigratable provider, bytes calldata data) internal {\n        _records[id].metadataProvider = provider;\n        provider.setMetadata(id, data);\n        emit MetadataSet(id, address(provider), data);\n    }\n}\n"},"@story-protocol/protocol-core/contracts/lib/IP.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n/// @title IP Library\n/// @notice Library for constants, structs, and helper functions used for IP.\nlibrary IP {\n    /// @notice Core metadata to associate with each IP.\n    struct MetadataV1 {\n        // The name associated with the IP.\n        string name;\n        // A keccak-256 hash of the IP content.\n        bytes32 hash;\n        // The date which the IP was registered.\n        uint64 registrationDate;\n        // The address of the initial IP registrant.\n        address registrant;\n        // An external URI associated with the IP.\n        string uri;\n    }\n}\n"},"@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// End consumer library.\nlibrary VRFV2PlusClient {\n  // extraArgs will evolve to support new features\n  bytes4 public constant EXTRA_ARGS_V1_TAG = bytes4(keccak256(\"VRF ExtraArgsV1\"));\n  struct ExtraArgsV1 {\n    bool nativePayment;\n  }\n\n  struct RandomWordsRequest {\n    bytes32 keyHash;\n    uint256 subId;\n    uint16 requestConfirmations;\n    uint32 callbackGasLimit;\n    uint32 numWords;\n    bytes extraArgs;\n  }\n\n  function _argsToBytes(ExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"},"@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IVRFCoordinatorV2Plus} from \"./interfaces/IVRFCoordinatorV2Plus.sol\";\nimport {IVRFMigratableConsumerV2Plus} from \"./interfaces/IVRFMigratableConsumerV2Plus.sol\";\nimport {ConfirmedOwner} from \"../../shared/access/ConfirmedOwner.sol\";\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinatorV2Plus.\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBaseV2Plus, and can\n * @dev initialize VRFConsumerBaseV2Plus's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumerV2Plus is VRFConsumerBaseV2Plus {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _subOwner)\n * @dev       VRFConsumerBaseV2Plus(_vrfCoordinator, _subOwner) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create a subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords, extraArgs),\n * @dev see (IVRFCoordinatorV2Plus for a description of the arguments).\n *\n * @dev Once the VRFCoordinatorV2Plus has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBaseV2Plus.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2Plus is IVRFMigratableConsumerV2Plus, ConfirmedOwner {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  error OnlyOwnerOrCoordinator(address have, address owner, address coordinator);\n  error ZeroAddress();\n\n  // s_vrfCoordinator should be used by consumers to make requests to vrfCoordinator\n  // so that coordinator reference is updated after migration\n  IVRFCoordinatorV2Plus public s_vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) ConfirmedOwner(msg.sender) {\n    if (_vrfCoordinator == address(0)) {\n      revert ZeroAddress();\n    }\n    s_vrfCoordinator = IVRFCoordinatorV2Plus(_vrfCoordinator);\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2Plus expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != address(s_vrfCoordinator)) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, address(s_vrfCoordinator));\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n\n  /**\n   * @inheritdoc IVRFMigratableConsumerV2Plus\n   */\n  function setCoordinator(address _vrfCoordinator) external override onlyOwnerOrCoordinator {\n    if (_vrfCoordinator == address(0)) {\n      revert ZeroAddress();\n    }\n    s_vrfCoordinator = IVRFCoordinatorV2Plus(_vrfCoordinator);\n\n    emit CoordinatorSet(_vrfCoordinator);\n  }\n\n  modifier onlyOwnerOrCoordinator() {\n    if (msg.sender != owner() && msg.sender != address(s_vrfCoordinator)) {\n      revert OnlyOwnerOrCoordinator(msg.sender, owner(), address(s_vrfCoordinator));\n    }\n    _;\n  }\n}\n"},"@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFCoordinatorV2Plus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {VRFV2PlusClient} from \"../libraries/VRFV2PlusClient.sol\";\nimport {IVRFSubscriptionV2Plus} from \"./IVRFSubscriptionV2Plus.sol\";\n\n// Interface that enables consumers of VRFCoordinatorV2Plus to be future-proof for upgrades\n// This interface is supported by subsequent versions of VRFCoordinatorV2Plus\ninterface IVRFCoordinatorV2Plus is IVRFSubscriptionV2Plus {\n  /**\n   * @notice Request a set of random words.\n   * @param req - a struct containing following fields for randomness request:\n   * keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * requestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * extraArgs - abi-encoded extra args\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(VRFV2PlusClient.RandomWordsRequest calldata req) external returns (uint256 requestId);\n}\n"},"@openzeppelin/contracts/utils/Base64.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.2) (utils/Base64.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 0x20)\n            let dataPtr := data\n            let endPtr := add(data, mload(data))\n\n            // In some cases, the last iteration will read bytes after the end of the data. We cache the value, and\n            // set it to zero to make sure no dirty bytes are read in that section.\n            let afterPtr := add(endPtr, 0x20)\n            let afterCache := mload(afterPtr)\n            mstore(afterPtr, 0x00)\n\n            // Run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 byte (24 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F to bitmask the least significant 6 bits.\n                // Use this as an index into the lookup table, mload an entire word\n                // so the desired character is in the least significant byte, and\n                // mstore8 this least significant byte into the result and continue.\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // Reset the value that was cached\n            mstore(afterPtr, afterCache)\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"},"@openzeppelin/contracts/utils/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"},"@openzeppelin/contracts/utils/Strings.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"},"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC721} from \"../ERC721.sol\";\nimport {Strings} from \"../../../utils/Strings.sol\";\nimport {IERC4906} from \"../../../interfaces/IERC4906.sol\";\nimport {IERC165} from \"../../../interfaces/IERC165.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is IERC4906, ERC721 {\n    using Strings for uint256;\n\n    // Interface ID as defined in ERC-4906. This does not correspond to a traditional interface ID as ERC-4906 only\n    // defines events and does not include any external function.\n    bytes4 private constant ERC4906_INTERFACE_ID = bytes4(0x49064906);\n\n    // Optional mapping for token URIs\n    mapping(uint256 tokenId => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC165-supportsInterface}\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, IERC165) returns (bool) {\n        return interfaceId == ERC4906_INTERFACE_ID || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via string.concat).\n        if (bytes(_tokenURI).length > 0) {\n            return string.concat(base, _tokenURI);\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Emits {MetadataUpdate}.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        _tokenURIs[tokenId] = _tokenURI;\n        emit MetadataUpdate(tokenId);\n    }\n}\n"},"@openzeppelin/contracts/token/ERC721/ERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"./IERC721.sol\";\nimport {IERC721Receiver} from \"./IERC721Receiver.sol\";\nimport {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Strings} from \"../../utils/Strings.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) private _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\n     * the `spender` for the specific `tokenId`.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {\n            _balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"},"@story-protocol/protocol-core/contracts/lib/modules/Module.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n// Default Module Type, all modules in this type by default\nstring constant MODULE_TYPE_DEFAULT = \"MODULE\";\n\nstring constant MODULE_TYPE_HOOK = \"HOOK_MODULE\";\n\n// String values for core protocol modules.\nstring constant IP_RESOLVER_MODULE_KEY = \"IP_RESOLVER_MODULE\";\n\n// String values for core protocol modules.\nstring constant REGISTRATION_MODULE_KEY = \"REGISTRATION_MODULE\";\n\n// String values for core protocol modules.\nstring constant LICENSING_MODULE_KEY = \"LICENSING_MODULE\";\n\n// String values for core protocol modules.\nstring constant DISPUTE_MODULE_KEY = \"DISPUTE_MODULE\";\n\nstring constant ROYALTY_MODULE_KEY = \"ROYALTY_MODULE\";\n\nstring constant TOKEN_WITHDRAWAL_MODULE_KEY = \"TOKEN_MANAGEMENT_MODULE\";\n"},"@story-protocol/protocol-core/contracts/resolvers/KeyValueResolver.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { IKeyValueResolver } from \"../interfaces/resolvers/IKeyValueResolver.sol\";\nimport { ResolverBase } from \"../resolvers/ResolverBase.sol\";\n\n/// @title Key Value Resolver\n/// @notice Resolver used for returning values associated with keys. This is the\n///         preferred approach for adding additional attribution to IP that the\n///         IP originator thinks is beneficial to have on chain.\nabstract contract KeyValueResolver is IKeyValueResolver, ResolverBase {\n    /// @dev Stores key-value pairs associated with each IP.\n    mapping(address => mapping(string => string)) internal _values;\n\n    /// @notice Sets the string value for a specified key of an IP ID.\n    /// @dev Enforced to be only callable by users with valid permission to call on behalf of the ipId.\n    /// @param ipId The canonical identifier of the IP asset.\n    /// @param key The string parameter key to update.\n    /// @param val The value to set for the specified key.\n    function setValue(address ipId, string calldata key, string calldata val) external virtual verifyPermission(ipId) {\n        _values[ipId][key] = val;\n        emit KeyValueSet(ipId, key, val);\n    }\n\n    /// @notice Retrieves the string value associated with a key for an IP asset.\n    /// @param key The string parameter key to query.\n    /// @return value The value associated with the specified key.\n    function value(address ipId, string calldata key) external view virtual returns (string memory) {\n        return _values[ipId][key];\n    }\n\n    /// @notice IERC165 interface support.\n    function supportsInterface(bytes4 id) public view virtual override returns (bool) {\n        return id == type(IKeyValueResolver).interfaceId || super.supportsInterface(id);\n    }\n}\n"},"@story-protocol/protocol-core/contracts/resolvers/ResolverBase.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { BaseModule } from \"../modules/BaseModule.sol\";\nimport { IResolver } from \"../interfaces/resolvers/IResolver.sol\";\nimport { AccessControlled } from \"../access/AccessControlled.sol\";\n\n/// @notice IP Resolver Base Contract\nabstract contract ResolverBase is IResolver, BaseModule, AccessControlled {\n    constructor(address accessController, address assetRegistry) AccessControlled(accessController, assetRegistry) {}\n\n    /// @notice IERC165 interface support.\n    function supportsInterface(bytes4 id) public view virtual override(BaseModule, IResolver) returns (bool) {\n        return id == type(IResolver).interfaceId || super.supportsInterface(id);\n    }\n}\n"},"@story-protocol/protocol-core/contracts/governance/Governable.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport { Errors } from \"../lib/Errors.sol\";\nimport { IGovernance } from \"../interfaces/governance/IGovernance.sol\";\nimport { IGovernable } from \"../interfaces/governance/IGovernable.sol\";\nimport { GovernanceLib } from \"../lib/GovernanceLib.sol\";\n\n/// @title Governable\n/// @dev All contracts managed by governance should inherit from this contract.\nabstract contract Governable is IGovernable {\n    /// @notice The address of the governance.\n    address public governance;\n\n    /// @dev Ensures that the function is called by the protocol admin.\n    modifier onlyProtocolAdmin() {\n        if (!IGovernance(governance).hasRole(GovernanceLib.PROTOCOL_ADMIN, msg.sender)) {\n            revert Errors.Governance__OnlyProtocolAdmin();\n        }\n        _;\n    }\n\n    modifier whenNotPaused() {\n        if (IGovernance(governance).getState() == GovernanceLib.ProtocolState.Paused) {\n            revert Errors.Governance__ProtocolPaused();\n        }\n        _;\n    }\n\n    /// @notice Constructs a new Governable contract.\n    /// @param governance_ The address of the governance.\n    constructor(address governance_) {\n        if (governance_ == address(0)) revert Errors.Governance__ZeroAddress();\n        governance = governance_;\n        emit GovernanceUpdated(governance);\n    }\n\n    /// @notice Sets a new governance address.\n    /// @param newGovernance The address of the new governance.\n    function setGovernance(address newGovernance) external onlyProtocolAdmin {\n        if (newGovernance == address(0)) revert Errors.Governance__ZeroAddress();\n        if (!ERC165Checker.supportsInterface(newGovernance, type(IGovernance).interfaceId))\n            revert Errors.Governance__UnsupportedInterface(\"IGovernance\");\n        if (IGovernance(newGovernance).getState() != IGovernance(governance).getState())\n            revert Errors.Governance__InconsistentState();\n        governance = newGovernance;\n        emit GovernanceUpdated(newGovernance);\n    }\n\n    /// @notice Returns the current governance address.\n    /// @return governance The address of the current governance.\n    function getGovernance() external view returns (address) {\n        return governance;\n    }\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/modules/IRegistrationModule.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { IPResolver } from \"../../resolvers/IPResolver.sol\";\n\ninterface IRegistrationModule {\n    /// @notice Emitted when a root-level IP is registered.\n    /// @param caller The address of the caller.\n    /// @param ipId The address of the IP that was registered.\n    /// @param policyId The policy that identifies the licensing terms of the IP.\n    event RootIPRegistered(address indexed caller, address indexed ipId, uint256 indexed policyId);\n\n    /// @notice Emitted when a derivative IP is registered.\n    /// @param caller The address of the caller.\n    /// @param ipId The address of the IP that was registered.\n    /// @param licenseIds The licenses that were used to register the derivative IP.\n    event DerivativeIPRegistered(address indexed caller, address indexed ipId, uint256[] licenseIds);\n\n    /// @notice Returns the metadata resolver used by the registration module.\n    function ipResolver() external view returns (IPResolver);\n\n    /// @notice Registers a root-level IP into the protocol. Root-level IPs can be thought of as organizational hubs\n    /// for encapsulating policies that actual IPs can use to register through. As such, a root-level IP is not an\n    /// actual IP, but a container for IP policy management for their child IP assets.\n    /// @param policyId The policy that identifies the licensing terms of the IP.\n    /// @param tokenContract The address of the NFT bound to the root-level IP.\n    /// @param tokenId The token id of the NFT bound to the root-level IP.\n    /// @param ipName The name assigned to the new IP.\n    /// @param contentHash The content hash of the IP being registered.\n    /// @param externalURL An external URI to link to the IP.\n    function registerRootIp(\n        uint256 policyId,\n        address tokenContract,\n        uint256 tokenId,\n        string memory ipName,\n        bytes32 contentHash,\n        string calldata externalURL\n    ) external returns (address);\n\n    /// @notice Registers derivative IPs into the protocol. Derivative IPs are IP assets that inherit policies from\n    /// parent IPs by burning acquired license NFTs.\n    /// @param licenseIds The licenses to incorporate for the new IP.\n    /// @param tokenContract The address of the NFT bound to the derivative IP.\n    /// @param tokenId The token id of the NFT bound to the derivative IP.\n    /// @param ipName The name assigned to the new IP.\n    /// @param contentHash The content hash of the IP being registered.\n    /// @param externalURL An external URI to link to the IP.\n    /// @param royaltyContext The royalty context for the derivative IP.\n    function registerDerivativeIp(\n        uint256[] calldata licenseIds,\n        address tokenContract,\n        uint256 tokenId,\n        string memory ipName,\n        bytes32 contentHash,\n        string calldata externalURL,\n        bytes calldata royaltyContext\n    ) external;\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/registries/IIPAssetRegistry.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { IIPAccountRegistry } from \"./IIPAccountRegistry.sol\";\nimport { IModuleRegistry } from \"./IModuleRegistry.sol\";\nimport { IMetadataProviderMigratable } from \"./metadata/IMetadataProviderMigratable.sol\";\nimport { IRegistrationModule } from \"../modules/IRegistrationModule.sol\";\n\n/// @title Interface for IP Account Registry\n/// @notice This interface manages the registration and tracking of IP Accounts\ninterface IIPAssetRegistry is IIPAccountRegistry {\n    // TODO: Deprecate `resolver` in favor of consolidation through the provider.\n    /// @notice Attributes for the IP asset type.\n    /// @param metadataProvider Metadata provider for Story Protocol canonicalized metadata.\n    /// @param resolver Metadata resolver for custom metadata added by the IP owner.\n    struct Record {\n        IMetadataProviderMigratable metadataProvider;\n        address resolver;\n    }\n\n    // TODO: Add support for optional licenseIds.\n    /// @notice Emits when an IP is officially registered into the protocol.\n    /// @param ipId The canonical identifier for the IP.\n    /// @param chainId The chain identifier of where the IP resides.\n    /// @param tokenContract The address of the IP.\n    /// @param tokenId The token identifier of the IP.\n    /// @param resolver The address of the resolver linked to the IP.\n    /// @param provider The address of the metadata provider linked to the IP.\n    /// @param metadata Canonical metadata that was linked to the IP.\n    event IPRegistered(\n        address ipId,\n        uint256 indexed chainId,\n        address indexed tokenContract,\n        uint256 indexed tokenId,\n        address resolver,\n        address provider,\n        bytes metadata\n    );\n\n    /// @notice Emits when an IP resolver is bound to an IP.\n    /// @param ipId The canonical identifier of the specified IP.\n    /// @param resolver The address of the new resolver bound to the IP.\n    event IPResolverSet(address ipId, address resolver);\n\n    /// @notice Emits when an operator is approved for IP registration for an NFT owner.\n    /// @param owner The address of the IP owner.\n    /// @param operator The address of the operator the owneris authorizing.\n    /// @param approved Whether or not to approve that operator for registration.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /// @notice Emits when metadata is set for an IP asset.\n    /// @param ipId The canonical identifier of the specified IP.\n    /// @param metadataProvider Address of the metadata provider associated with the IP.\n    /// @param metadata The canonical metadata in bytes associated with the IP.\n    event MetadataSet(address indexed ipId, address indexed metadataProvider, bytes metadata);\n\n    /// @notice The canonical module registry used by the protocol.\n    function MODULE_REGISTRY() external view returns (IModuleRegistry);\n\n    /// @notice The registration module that interacts with IPAssetRegistry.\n    function REGISTRATION_MODULE() external view returns (IRegistrationModule);\n\n    /// @notice Tracks the total number of IP assets in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Checks whether an operator is approved to register on behalf of an IP owner.\n    /// @param owner The address of the IP owner whose approval is being checked for.\n    /// @param operator The address of the operator the owner has approved for registration delgation.\n    /// @return Whether the operator is approved on behalf of the owner for registering.\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /// @notice Enables third party operators to register on behalf of an NFT owner.\n    /// @param operator The address of the operator the sender authorizes.\n    /// @param approved Whether or not to approve that operator for registration.\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /// @notice Registers an NFT as IP, creating a corresponding IP record.\n    /// @param chainId The chain identifier of where the NFT resides.\n    /// @param tokenContract The address of the NFT.\n    /// @param tokenId The token identifier of the NFT.\n    /// @param resolverAddr The address of the resolver to associate with the IP.\n    /// @param createAccount Whether to create an IP account when registering.\n    /// @param metadata_ Metadata in bytes to associate with the IP.\n    /// @return ipId_ The address of the newly registered IP.\n    function register(\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId,\n        address resolverAddr,\n        bool createAccount,\n        bytes calldata metadata_\n    ) external returns (address);\n\n    /// @notice Registers an NFT as an IP using licenses derived from parent IP asset(s).\n    /// @param licenseIds The parent IP asset licenses used to derive the new IP asset.\n    /// @param royaltyContext The context for the royalty module to process.\n    /// @param chainId The chain identifier of where the NFT resides.\n    /// @param tokenContract The address of the NFT.\n    /// @param tokenId The token identifier of the NFT.\n    /// @param resolverAddr The address of the resolver to associate with the IP.\n    /// @param createAccount Whether to create an IP account when registering.\n    /// @param metadata_ Metadata in bytes to associate with the IP.\n    /// @return ipId_ The address of the newly registered IP.\n    function register(\n        uint256[] calldata licenseIds,\n        bytes calldata royaltyContext,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId,\n        address resolverAddr,\n        bool createAccount,\n        bytes calldata metadata_\n    ) external returns (address);\n\n    /// @notice Gets the canonical IP identifier associated with an IP NFT.\n    /// @dev This is equivalent to the address of its bound IP account.\n    /// @param chainId The chain identifier of where the IP resides.\n    /// @param tokenContract The address of the IP.\n    /// @param tokenId The token identifier of the IP.\n    /// @return ipId The IP's canonical address identifier.\n    function ipId(uint256 chainId, address tokenContract, uint256 tokenId) external view returns (address);\n\n    /// @notice Checks whether an IP was registered based on its ID.\n    /// @param id The canonical identifier for the IP.\n    /// @return isRegistered Whether the IP was registered into the protocol.\n    function isRegistered(address id) external view returns (bool);\n\n    /// @notice Gets the resolver bound to an IP based on its ID.\n    /// @param id The canonical identifier for the IP.\n    /// @return resolver The IP resolver address if registered, else the zero address.\n    function resolver(address id) external view returns (address);\n\n    /// @notice Gets the metadata provider used for new metadata registrations.\n    /// @return metadataProvider The address of the metadata provider used for new IP registrations.\n    function metadataProvider() external view returns (address);\n\n    /// @notice Gets the metadata provider linked to an IP based on its ID.\n    /// @param id The canonical identifier for the IP.\n    /// @return metadataProvider The metadata provider that was bound to this IP at creation time.\n    function metadataProvider(address id) external view returns (address);\n\n    /// @notice Gets the underlying canonical metadata linked to an IP asset.\n    /// @param id The canonical ID of the IP asset.\n    /// @return metadata The metadata that was bound to this IP at creation time.\n    function metadata(address id) external view returns (bytes memory);\n\n    /// @notice Sets the underlying metadata for an IP asset.\n    /// @dev As metadata is immutable but additive, this will only be used when an IP migrates from a new provider that\n    /// introduces new attributes.\n    /// @param id The canonical ID of the IP.\n    /// @param data Canonical metadata to associate with the IP.\n    function setMetadata(address id, address metadataProvider, bytes calldata data) external;\n\n    /// @notice Sets the resolver for an IP based on its canonical ID.\n    /// @param id The canonical ID of the IP.\n    /// @param resolverAddr The address of the resolver being set.\n    function setResolver(address id, address resolverAddr) external;\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/modules/licensing/ILicensingModule.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { Licensing } from \"../../../lib/Licensing.sol\";\nimport { IModule } from \"../base/IModule.sol\";\nimport { RoyaltyModule } from \"../../../modules/royalty/RoyaltyModule.sol\";\nimport { ILicenseRegistry } from \"../../registries/ILicenseRegistry.sol\";\nimport { IDisputeModule } from \"../dispute/IDisputeModule.sol\";\n\n/// @title ILicensingModule\ninterface ILicensingModule is IModule {\n    /// @notice Status of a policy on IP asset\n    /// @param index The local index of the policy in the IP asset\n    /// @param isSet True if the policy is set in the IP asset\n    /// @param active True if the policy is active\n    /// @param isInherited True if the policy is inherited from a parent IP asset\n    struct PolicySetup {\n        uint256 index;\n        bool isSet;\n        bool active;\n        bool isInherited;\n    }\n\n    /// @notice Emitted when a policy framework is created by registering a policy framework manager\n    /// @param framework The address of the IPolicyFrameworkManager\n    /// @param framework The policy framework data\n    event PolicyFrameworkRegistered(address indexed framework, string name, string licenseTextUrl);\n\n    /// @notice Emitted when a policy is added to the contract\n    /// @param policyId The id of the policy\n    /// @param policyFrameworkManager The address of the policy framework manager\n    /// @param frameworkData The policy framework specific encoded data\n    /// @param royaltyPolicy The address of the royalty policy\n    /// @param royaltyData The royalty policy specific encoded data\n    /// @param mintingFee The fee to be paid when minting a license\n    /// @param mintingFeeToken The token to be used to pay the minting fee\n    event PolicyRegistered(\n        uint256 indexed policyId,\n        address indexed policyFrameworkManager,\n        bytes frameworkData,\n        address royaltyPolicy,\n        bytes royaltyData,\n        uint256 mintingFee,\n        address mintingFeeToken\n    );\n\n    /// @notice Emitted when a policy is added to an IP\n    /// @param caller The address that called the function\n    /// @param ipId The id of the IP\n    /// @param policyId The id of the policy\n    /// @param index The index of the policy in the IP's policy set\n    /// @param isInherited Whether the policy was inherited from a parent IP (linking) or set by IP owner\n    event PolicyAddedToIpId(\n        address indexed caller,\n        address indexed ipId,\n        uint256 indexed policyId,\n        uint256 index,\n        bool isInherited\n    );\n\n    /// @notice Emitted when an IP is linked to its parent by burning a license\n    /// @param caller The address that called the function\n    /// @param ipId The id of the IP\n    /// @param parentIpIds The ids of the parent IPs\n    event IpIdLinkedToParents(address indexed caller, address indexed ipId, address[] parentIpIds);\n\n    /// @notice Returns the canonical protocol-wide RoyaltyModule\n    function ROYALTY_MODULE() external view returns (RoyaltyModule);\n\n    /// @notice Returns the canonical protocol-wide LicenseRegistry\n    function LICENSE_REGISTRY() external view returns (ILicenseRegistry);\n\n    /// @notice Returns the canonical protocol-wide DisputeModule\n    function DISPUTE_MODULE() external view returns (IDisputeModule);\n\n    /// @notice Registers a policy framework manager into the contract, so it can add policy data for licenses.\n    /// @param manager the address of the manager. Will be ERC165 checked for IPolicyFrameworkManager\n    function registerPolicyFrameworkManager(address manager) external;\n\n    /// @notice Registers a policy into the contract. MUST be called by a registered\n    /// framework or it will revert. The policy data and its integrity must be\n    /// verified by the policy framework manager.\n    /// @param pol The Licensing policy data. MUST have same policy framework as the caller address\n    /// @return policyId The id of the newly registered policy\n    function registerPolicy(Licensing.Policy memory pol) external returns (uint256 policyId);\n\n    /// @notice Adds a policy to the set of policies of an IP\n    /// @param ipId The id of the IP\n    /// @param polId The id of the policy\n    /// @return indexOnIpId The index of the policy in the IP's policy set\n    function addPolicyToIp(address ipId, uint256 polId) external returns (uint256 indexOnIpId);\n\n    /// @notice Mints a license to create derivative IP. License NFTs represent a policy granted by IPs (licensors).\n    /// Reverts if caller is not authorized by any of the licensors.\n    /// @dev This NFT needs to be burned in order to link a derivative IP with its parents. If this is the first\n    /// combination of policy and licensors, a new licenseId will be created (by incrementing prev totalLicenses).\n    /// If not, the license is fungible and an id will be reused. The licensing terms that regulate creating new\n    /// licenses will be verified to allow minting.\n    /// @param policyId The id of the policy with the licensing parameters\n    /// @param licensorIpId The id of the licensor IP\n    /// @param amount The amount of licenses to mint\n    /// @param receiver The address that will receive the license\n    /// @param royaltyContext The context for the royalty module to process\n    /// @return licenseId The ID of the license NFT(s)\n    function mintLicense(\n        uint256 policyId,\n        address licensorIpId,\n        uint256 amount,\n        address receiver,\n        bytes calldata royaltyContext\n    ) external returns (uint256 licenseId);\n\n    /// @notice Links an IP to the licensors listed in the license NFTs, if their policies allow it. Burns the license\n    /// NFTs in the proccess. The caller must be the owner of the IP asset and license NFTs.\n    /// @param licenseIds The id of the licenses to burn\n    /// @param childIpId The id of the child IP to be linked\n    /// @param royaltyContext The context for the royalty module to process\n    function linkIpToParents(uint256[] calldata licenseIds, address childIpId, bytes calldata royaltyContext) external;\n\n    ///\n    /// Getters\n    ///\n\n    /// @notice Returns if the framework address is registered in the LicensingModule.\n    /// @param policyFramework The address of the policy framework manager\n    /// @return isRegistered True if the framework is registered\n    function isFrameworkRegistered(address policyFramework) external view returns (bool);\n\n    /// @notice Returns amount of distinct licensing policies in the LicensingModule.\n    /// @return totalPolicies The amount of policies\n    function totalPolicies() external view returns (uint256);\n\n    /// @notice Returns the policy data for policyId, reverts if not found.\n    /// @param policyId The id of the policy\n    /// @return pol The policy data\n    function policy(uint256 policyId) external view returns (Licensing.Policy memory pol);\n\n    /// @notice Returns the policy id for the given policy data, or 0 if not found.\n    /// @param pol The policy data in Policy struct\n    /// @return policyId The id of the policy\n    function getPolicyId(Licensing.Policy calldata pol) external view returns (uint256 policyId);\n\n    /// @notice Returns the policy aggregator data for the given IP ID in the framework.\n    /// @param framework The address of the policy framework manager\n    /// @param ipId The id of the IP asset\n    /// @return data The encoded policy aggregator data to be decoded by the framework manager\n    function policyAggregatorData(address framework, address ipId) external view returns (bytes memory);\n\n    /// @notice Returns if policyId exists in the LicensingModule\n    /// @param policyId The id of the policy\n    /// @return isDefined True if the policy is defined\n    function isPolicyDefined(uint256 policyId) external view returns (bool);\n\n    /// @notice Returns the policy ids attached to an IP\n    /// @dev Potentially gas-intensive operation, use with care.\n    /// @param isInherited True if the policy is inherited from a parent IP\n    /// @param ipId The id of the IP asset\n    /// @return policyIds The ids of policy ids for the IP\n    function policyIdsForIp(bool isInherited, address ipId) external view returns (uint256[] memory policyIds);\n\n    /// @notice Returns the total number of policies attached to an IP\n    /// @param isInherited True if the policy is inherited from a parent IP\n    /// @param ipId The id of the IP asset\n    /// @return totalPolicies The total number of policies for the IP\n    function totalPoliciesForIp(bool isInherited, address ipId) external view returns (uint256);\n\n    /// @notice Returns if a given policyId is attached to an IP\n    /// @param isInherited True if the policy is inherited from a parent IP\n    /// @param ipId The id of the IP asset\n    /// @param policyId The id of the policy\n    /// @return isSet True if the policy is set in the IP asset\n    function isPolicyIdSetForIp(bool isInherited, address ipId, uint256 policyId) external view returns (bool);\n\n    /// @notice Returns the policy ID for an IP by local index on the IP's policy set\n    /// @param isInherited True if the policy is inherited from a parent IP\n    /// @param ipId The id of the IP asset to check\n    /// @param index The local index of a policy in the IP's policy set\n    /// @return policyId The id of the policy\n    function policyIdForIpAtIndex(\n        bool isInherited,\n        address ipId,\n        uint256 index\n    ) external view returns (uint256 policyId);\n\n    /// @notice Returns the policy data for an IP by the policy's local index on the IP's policy set\n    /// @param isInherited True if the policy is inherited from a parent IP\n    /// @param ipId The id of the IP asset to check\n    /// @param index The local index of a policy in the IP's policy set\n    /// @return policy The policy data\n    function policyForIpAtIndex(\n        bool isInherited,\n        address ipId,\n        uint256 index\n    ) external view returns (Licensing.Policy memory);\n\n    /// @notice Returns the status of a policy in an IP's policy set\n    /// @param ipId The id of the IP asset to check\n    /// @param policyId The id of the policy\n    /// @return index The local index of the policy in the IP's policy set\n    /// @return isInherited True if the policy is inherited from a parent IP\n    /// @return active True if the policy is active\n    function policyStatus(\n        address ipId,\n        uint256 policyId\n    ) external view returns (uint256 index, bool isInherited, bool active);\n\n    /// @notice Returns if the given policy attached to the given IP is inherited from a parent IP.\n    /// @param ipId The id of the IP asset that has the policy attached\n    /// @param policyId The id of the policy to check if inherited\n    /// @return isInherited True if the policy is inherited from a parent IP\n    function isPolicyInherited(address ipId, uint256 policyId) external view returns (bool);\n\n    /// @notice Returns if an IP is a derivative of another IP\n    /// @param parentIpId The id of the parent IP asset to check\n    /// @param childIpId The id of the child IP asset to check\n    /// @return isParent True if the child IP is a derivative of the parent IP\n    function isParent(address parentIpId, address childIpId) external view returns (bool);\n\n    /// @notice Returns the list of parent IP assets for a given child IP asset\n    /// @param ipId The id of the child IP asset to check\n    /// @return parentIpIds The ids of the parent IP assets\n    function parentIpIds(address ipId) external view returns (address[] memory);\n\n    /// @notice Returns the total number of parents for an IP asset\n    /// @param ipId The id of the IP asset to check\n    /// @return totalParents The total number of parent IP assets\n    function totalParentsForIpId(address ipId) external view returns (uint256);\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/registries/IModuleRegistry.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n/// @title IModuleRegistry\n/// @dev This interface defines the methods for a module registry in the Story Protocol.\ninterface IModuleRegistry {\n    /// @notice Emitted when a new module is added to the registry.\n    /// @param name The name of the module.\n    /// @param module The address of the module.\n    event ModuleAdded(string name, address indexed module, bytes4 indexed moduleTypeInterfaceId, string moduleType);\n\n    /// @notice Emitted when a module is removed from the registry.\n    /// @param name The name of the module.\n    /// @param module The address of the module.\n    event ModuleRemoved(string name, address indexed module);\n\n    /// @notice Returns the address of a registered module by its name.\n    /// @param name The name of the module.\n    /// @return moduleAddress The address of the module.\n    function getModule(string memory name) external view returns (address);\n\n    /// @notice Returns the module type of a registered module by its address.\n    /// @param moduleAddress The address of the module.\n    /// @return moduleType The type of the module as a string.\n    function getModuleType(address moduleAddress) external view returns (string memory);\n\n    /// @notice Returns the interface ID of a registered module type.\n    /// @param moduleType The name of the module type.\n    /// @return moduleTypeInterfaceId The interface ID of the module type as bytes4.\n    function getModuleTypeInterfaceId(string memory moduleType) external view returns (bytes4);\n\n    /// @notice Registers a new module type in the registry associate with an interface.\n    /// @dev Enforced to be only callable by the protocol admin in governance.\n    /// @param name The name of the module type to be registered.\n    /// @param interfaceId The interface ID associated with the module type.\n    function registerModuleType(string memory name, bytes4 interfaceId) external;\n\n    /// @notice Removes a module type from the registry.\n    /// @dev Enforced to be only callable by the protocol admin in governance.\n    /// @param name The name of the module type to be removed.\n    function removeModuleType(string memory name) external;\n\n    /// @notice Registers a new module in the registry.\n    /// @dev Enforced to be only callable by the protocol admin in governance.\n    /// @param name The name of the module.\n    /// @param moduleAddress The address of the module.\n    function registerModule(string memory name, address moduleAddress) external;\n\n    /// @notice Registers a new module in the registry with an associated module type.\n    /// @param name The name of the module to be registered.\n    /// @param moduleAddress The address of the module.\n    /// @param moduleType The type of the module being registered.\n    function registerModule(string memory name, address moduleAddress, string memory moduleType) external;\n\n    /// @notice Removes a module from the registry.\n    /// @dev Enforced to be only callable by the protocol admin in governance.\n    /// @param name The name of the module.\n    function removeModule(string memory name) external;\n\n    /// @notice Checks if a module is registered in the protocol.\n    /// @param moduleAddress The address of the module.\n    /// @return isRegistered True if the module is registered, false otherwise.\n    function isRegistered(address moduleAddress) external view returns (bool);\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/resolvers/IResolver.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n/// @notice Resolver Interface\ninterface IResolver {\n    /// @notice Checks whether the resolver IP interface is supported.\n    function supportsInterface(bytes4 id) external view returns (bool);\n}\n"},"@story-protocol/protocol-core/contracts/lib/Errors.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n/// @title Errors Library\n/// @notice Library for all Story Protocol contract errors.\nlibrary Errors {\n    ////////////////////////////////////////////////////////////////////////////\n    //                                Governance                              //\n    ////////////////////////////////////////////////////////////////////////////\n    error Governance__OnlyProtocolAdmin();\n    error Governance__ZeroAddress();\n    error Governance__ProtocolPaused();\n    error Governance__InconsistentState();\n    error Governance__NewStateIsTheSameWithOldState();\n    error Governance__UnsupportedInterface(string interfaceName);\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                                IPAccount                               //\n    ////////////////////////////////////////////////////////////////////////////\n    error IPAccount__InvalidSigner();\n    error IPAccount__InvalidSignature();\n    error IPAccount__ExpiredSignature();\n    error IPAccount__InvalidCalldata();\n    error IPAccount__InvalidAccessController();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                                   Module                               //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The caller is not allowed to call the provided module.\n    error Module_Unauthorized();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                               IPAccountRegistry                        //\n    ////////////////////////////////////////////////////////////////////////////\n    error IPAccountRegistry_InvalidIpAccountImpl();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                               IPAssetRegistry                         //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The IP asset has already been registered.\n    error IPAssetRegistry__AlreadyRegistered();\n\n    /// @notice The IP account has already been created.\n    error IPAssetRegistry__IPAccountAlreadyCreated();\n\n    /// @notice The IP asset has not yet been registered.\n    error IPAssetRegistry__NotYetRegistered();\n\n    /// @notice The IP asset registrant is not authorized.\n    error IPAssetRegistry__RegistrantUnauthorized();\n\n    /// @notice The specified IP resolver is not valid.\n    error IPAssetRegistry__ResolverInvalid();\n\n    /// @notice Caller not authorized to perform the IP registry function call.\n    error IPAssetRegistry__Unauthorized();\n\n    /// @notice The deployed address of account doesn't match with IP ID.\n    error IPAssetRegistry__InvalidAccount();\n\n    /// @notice The metadata provider is not valid.\n    error IPAssetRegistry__InvalidMetadataProvider();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                                 IPResolver                            ///\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The targeted IP does not yet have an IP account.\n    error IPResolver_InvalidIP();\n\n    /// @notice Caller not authorized to perform the IP resolver function call.\n    error IPResolver_Unauthorized();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                          Metadata Provider                            ///\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Provided hash metadata is not valid.\n    error MetadataProvider__HashInvalid();\n\n    /// @notice The caller is not the authorized IP asset owner.\n    error MetadataProvider__IPAssetOwnerInvalid();\n\n    /// @notice Provided hash metadata is not valid.\n    error MetadataProvider__NameInvalid();\n\n    /// @notice The new metadata provider is not compatible with the old provider.\n    error MetadataProvider__MetadataNotCompatible();\n\n    /// @notice Provided registrant metadata is not valid.\n    error MetadataProvider__RegistrantInvalid();\n\n    /// @notice Provided registration date is not valid.\n    error MetadataProvider__RegistrationDateInvalid();\n\n    /// @notice Caller does not access to set metadata storage for the provider.\n    error MetadataProvider__Unauthorized();\n\n    /// @notice A metadata provider upgrade is not currently available.\n    error MetadataProvider__UpgradeUnavailable();\n\n    /// @notice The upgrade provider is not valid.\n    error MetadataProvider__UpgradeProviderInvalid();\n\n    /// @notice Provided metadata URI is not valid.\n    error MetadataProvider__URIInvalid();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                            LicenseRegistry                             //\n    ////////////////////////////////////////////////////////////////////////////\n\n    error LicenseRegistry__CallerNotLicensingModule();\n    error LicenseRegistry__ZeroLicensingModule();\n    error LicensingModule__CallerNotLicenseRegistry();\n    error LicenseRegistry__RevokedLicense();\n    /// @notice emitted when trying to transfer a license that is not transferable (by policy)\n    error LicenseRegistry__NotTransferable();\n    /// @notice emitted on constructor if dispute module is not set\n    error LicenseRegistry__ZeroDisputeModule();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                            LicensingModule                             //\n    ////////////////////////////////////////////////////////////////////////////\n\n    error LicensingModule__PolicyAlreadySetForIpId();\n    error LicensingModule__FrameworkNotFound();\n    error LicensingModule__EmptyLicenseUrl();\n    error LicensingModule__InvalidPolicyFramework();\n    error LicensingModule__ParamVerifierLengthMismatch();\n    error LicensingModule__PolicyNotFound();\n    error LicensingModule__NotLicensee();\n    error LicensingModule__ParentIdEqualThanChild();\n    error LicensingModule__LicensorDoesntHaveThisPolicy();\n    error LicensingModule__MintLicenseParamFailed();\n    error LicensingModule__LinkParentParamFailed();\n    error LicensingModule__TransferParamFailed();\n    error LicensingModule__InvalidLicensor();\n    error LicensingModule__ParamVerifierAlreadySet();\n    error LicensingModule__CommercialTermInNonCommercialPolicy();\n    error LicensingModule__EmptyParamName();\n    error LicensingModule__UnregisteredFrameworkAddingPolicy();\n    error LicensingModule__UnauthorizedAccess();\n    error LicensingModule__LicensorNotRegistered();\n    error LicensingModule__CallerNotLicensorAndPolicyNotSet();\n    error LicensingModule__DerivativesCannotAddPolicy();\n    error LicensingModule__IncompatibleRoyaltyPolicyAddress();\n    error LicensingModule__IncompatibleRoyaltyPolicyDerivativeRevShare();\n    error LicensingModule__IncompatibleLicensorCommercialPolicy();\n    error LicensingModule__IncompatibleLicensorRoyaltyDerivativeRevShare();\n    error LicensingModule__DerivativeRevShareSumExceedsMaxRNFTSupply();\n    error LicensingModule__MismatchBetweenRoyaltyPolicy();\n    error LicensingModule__RegisterPolicyFrameworkMismatch();\n    error LicensingModule__RoyaltyPolicyNotWhitelisted();\n    error LicensingModule__MintingFeeTokenNotWhitelisted();\n    error LicensingModule__ReceiverZeroAddress();\n    error LicensingModule__MintAmountZero();\n    /// @notice emitted when trying to interact with an IP that has been disputed in the DisputeModule\n    error LicensingModule__DisputedIpId();\n    /// @notice emitted when linking a license from a licensor that has been disputed in the DisputeModule\n    error LicensingModule__LinkingRevokedLicense();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                        LicensingModuleAware                            //\n    ////////////////////////////////////////////////////////////////////////////\n\n    error LicensingModuleAware__CallerNotLicensingModule();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                         PolicyFrameworkManager                         //\n    ////////////////////////////////////////////////////////////////////////////\n\n    error PolicyFrameworkManager__GettingPolicyWrongFramework();\n    error PolicyFrameworkManager__CommercializerCheckerDoesNotSupportHook(address commercializer);\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                     LicensorApprovalChecker                            //\n    ////////////////////////////////////////////////////////////////////////////\n    error LicensorApprovalChecker__Unauthorized();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                            Dispute Module                              //\n    ////////////////////////////////////////////////////////////////////////////\n\n    error DisputeModule__ZeroArbitrationPolicy();\n    error DisputeModule__ZeroArbitrationRelayer();\n    error DisputeModule__ZeroDisputeTag();\n    error DisputeModule__ZeroLinkToDisputeEvidence();\n    error DisputeModule__NotWhitelistedArbitrationPolicy();\n    error DisputeModule__NotWhitelistedDisputeTag();\n    error DisputeModule__NotWhitelistedArbitrationRelayer();\n    error DisputeModule__NotDisputeInitiator();\n    error DisputeModule__NotInDisputeState();\n    error DisputeModule__NotAbleToResolve();\n    error DisputeModule__NotRegisteredIpId();\n    error DisputeModule__UnauthorizedAccess();\n\n    error ArbitrationPolicySP__ZeroDisputeModule();\n    error ArbitrationPolicySP__ZeroPaymentToken();\n    error ArbitrationPolicySP__NotDisputeModule();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                            Royalty Module                              //\n    ////////////////////////////////////////////////////////////////////////////\n\n    error RoyaltyModule__ZeroRoyaltyPolicy();\n    error RoyaltyModule__NotWhitelistedRoyaltyPolicy();\n    error RoyaltyModule__ZeroRoyaltyToken();\n    error RoyaltyModule__NotWhitelistedRoyaltyToken();\n    error RoyaltyModule__NoRoyaltyPolicySet();\n    error RoyaltyModule__IncompatibleRoyaltyPolicy();\n    error RoyaltyModule__NotAllowedCaller();\n    error RoyaltyModule__ZeroLicensingModule();\n    error RoyaltyModule__CanOnlyMintSelectedPolicy();\n    error RoyaltyModule__NoParentsOnLinking();\n    error RoyaltyModule__NotRegisteredIpId();\n\n    error RoyaltyPolicyLAP__ZeroRoyaltyModule();\n    error RoyaltyPolicyLAP__ZeroLiquidSplitFactory();\n    error RoyaltyPolicyLAP__ZeroLiquidSplitMain();\n    error RoyaltyPolicyLAP__NotRoyaltyModule();\n    error RoyaltyPolicyLAP__ZeroLicensingModule();\n    error RoyaltyPolicyLAP__AboveParentLimit();\n    error RoyaltyPolicyLAP__AboveAncestorsLimit();\n    error RoyaltyPolicyLAP__AboveRoyaltyStackLimit();\n    error RoyaltyPolicyLAP__InvalidAncestorsLength();\n    error RoyaltyPolicyLAP__InvalidAncestors();\n    error RoyaltyPolicyLAP__InvalidRoyaltyAmountLength();\n    error RoyaltyPolicyLAP__InvalidAncestorsHash();\n    error RoyaltyPolicyLAP__InvalidParentRoyaltiesLength();\n    error RoyaltyPolicyLAP__InvalidAncestorsRoyalty();\n    error RoyaltyPolicyLAP__ImplementationAlreadySet();\n    error RoyaltyPolicyLAP__ZeroAncestorsVaultImpl();\n    error RoyaltyPolicyLAP__NotFullOwnership();\n    error RoyaltyPolicyLAP__UnlinkableToParents();\n    error RoyaltyPolicyLAP__TransferFailed();\n    error RoyaltyPolicyLAP__LastPositionNotAbleToMintLicense();\n\n    error AncestorsVaultLAP__ZeroRoyaltyPolicyLAP();\n    error AncestorsVaultLAP__AlreadyClaimed();\n    error AncestorsVaultLAP__InvalidAncestorsHash();\n    error AncestorsVaultLAP__InvalidClaimer();\n    error AncestorsVaultLAP__ClaimerNotAnAncestor();\n    error AncestorsVaultLAP__ETHBalanceNotZero();\n    error AncestorsVaultLAP__ERC20BalanceNotZero();\n    error AncestorsVaultLAP__TransferFailed();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                             ModuleRegistry                             //\n    ////////////////////////////////////////////////////////////////////////////\n\n    error ModuleRegistry__ModuleAddressZeroAddress();\n    error ModuleRegistry__ModuleAddressNotContract();\n    error ModuleRegistry__ModuleAlreadyRegistered();\n    error ModuleRegistry__NameEmptyString();\n    error ModuleRegistry__NameAlreadyRegistered();\n    error ModuleRegistry__NameDoesNotMatch();\n    error ModuleRegistry__ModuleNotRegistered();\n    error ModuleRegistry__InterfaceIdZero();\n    error ModuleRegistry__ModuleTypeAlreadyRegistered();\n    error ModuleRegistry__ModuleTypeNotRegistered();\n    error ModuleRegistry__ModuleNotSupportExpectedModuleTypeInterfaceId();\n    error ModuleRegistry__ModuleTypeEmptyString();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                               RegistrationModule                       //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The caller is not the owner of the root IP NFT.\n    error RegistrationModule__InvalidOwner();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                             AccessController                           //\n    ////////////////////////////////////////////////////////////////////////////\n\n    error AccessController__IPAccountIsZeroAddress();\n    error AccessController__IPAccountIsNotValid(address ipAccount);\n    error AccessController__SignerIsZeroAddress();\n    error AccessController__CallerIsNotIPAccount();\n    error AccessController__PermissionIsNotValid();\n    error AccessController__BothCallerAndRecipientAreNotRegisteredModule(address signer, address to);\n    error AccessController__PermissionDenied(address ipAccount, address signer, address to, bytes4 func);\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                             AccessControlled                           //\n    ////////////////////////////////////////////////////////////////////////////\n    error AccessControlled__ZeroAddress();\n    error AccessControlled__NotIpAccount(address ipAccount);\n    error AccessControlled__CallerIsNotIpAccount(address caller);\n}\n"},"@story-protocol/protocol-core/contracts/registries/metadata/MetadataProviderV1.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { IP } from \"../../lib/IP.sol\";\nimport { MetadataProviderBase } from \"./MetadataProviderBase.sol\";\nimport { Errors } from \"../../lib/Errors.sol\";\n\n/// @title IP Metadata Provider v1\n/// @notice Storage provider for Story Protocol canonical IP metadata (v1).\ncontract MetadataProviderV1 is MetadataProviderBase {\n    /// @notice Initializes the metadata provider contract.\n    /// @param ipAssetRegistry The protocol-wide IP asset registry.\n    constructor(address ipAssetRegistry) MetadataProviderBase(ipAssetRegistry) {}\n\n    /// @notice Fetches the metadata linked to an IP asset.\n    /// @param ipId The address identifier of the IP asset.\n    /// @return metadata The metadata linked to the IP asset.\n    function metadata(address ipId) external view returns (IP.MetadataV1 memory) {\n        return _metadataV1(ipId);\n    }\n\n    /// @notice Gets the name associated with the IP asset.\n    /// @param ipId The address identifier of the IP asset.\n    /// @return name The name associated with the IP asset.\n    function name(address ipId) external view returns (string memory) {\n        return _metadataV1(ipId).name;\n    }\n\n    /// @notice Gets the hash associated with the IP asset.\n    /// @param ipId The address identifier of the IP asset.\n    /// @return hash The hash associated with the IP asset.\n    function hash(address ipId) external view returns (bytes32) {\n        return _metadataV1(ipId).hash;\n    }\n\n    /// @notice Gets the date in which the IP asset was registered.\n    /// @param ipId The address identifier of the IP asset.\n    /// @return registrationDate The date in which the IP asset was registered.\n    function registrationDate(address ipId) external view returns (uint64) {\n        return _metadataV1(ipId).registrationDate;\n    }\n\n    /// @notice Gets the initial registrant address of the IP asset.\n    /// @param ipId The address identifier of the IP asset.\n    /// @return registrant The initial registrant address of the IP asset.\n    function registrant(address ipId) external view returns (address) {\n        return _metadataV1(ipId).registrant;\n    }\n\n    /// @notice Gets the external URI associated with the IP asset.\n    /// @param ipId The address identifier of the IP asset.\n    /// @return uri The external URI associated with the IP asset.\n    function uri(address ipId) external view returns (string memory) {\n        return _metadataV1(ipId).uri;\n    }\n\n    /// @dev Checks that the data conforms to the canonical metadata standards.\n    /// @param data The canonical metadata in bytes to verify.\n    function _verifyMetadata(bytes memory data) internal virtual override {\n        IP.MetadataV1 memory decodedMetadata = abi.decode(data, (IP.MetadataV1));\n        if (decodedMetadata.registrant == address(0)) {\n            revert Errors.MetadataProvider__RegistrantInvalid();\n        }\n    }\n\n    /// @dev Checks whether two sets of metadata are compatible with one another.\n    /// TODO: Add try-catch for ABI-decoding error handling.\n    function _compatible(bytes memory m1, bytes memory m2) internal pure virtual override returns (bool) {\n        IP.MetadataV1 memory m1Decoded = abi.decode(m1, (IP.MetadataV1));\n        IP.MetadataV1 memory m2Decoded = abi.decode(m2, (IP.MetadataV1));\n        return _hash(m1Decoded) == _hash(m2Decoded);\n    }\n\n    /// @dev Gets the bytes32 hash for a MetadataV1 data struct.\n    function _hash(IP.MetadataV1 memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encode(data.name, data.hash, data.registrationDate, data.registrant, data.uri));\n    }\n\n    /// @dev Get the decoded canonical metadata belonging to an IP asset.\n    function _metadataV1(address ipId) internal view returns (IP.MetadataV1 memory) {\n        return abi.decode(_ipMetadata[ipId], (IP.MetadataV1));\n    }\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/registries/metadata/IMetadataProviderMigratable.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { IMetadataProvider } from \"./IMetadataProvider.sol\";\nimport { IIPAssetRegistry } from \"../IIPAssetRegistry.sol\";\n\n/// @title Metadata Provider Interface\ninterface IMetadataProviderMigratable is IMetadataProvider {\n    /// @notice Returns the protocol-wide IP asset registry.\n    function IP_ASSET_REGISTRY() external view returns (IIPAssetRegistry);\n\n    /// @notice Returns the new metadata provider IP assets may migrate to.\n    function upgradeProvider() external returns (IMetadataProvider);\n\n    /// @notice Sets a upgrade provider for users to migrate their metadata to.\n    /// @param provider The address of the new metadata provider to migrate to.\n    function setUpgradeProvider(address provider) external;\n\n    /// @notice Updates the provider used by the IP asset, migrating existing metadata to the new provider, and adding\n    /// new metadata.\n    /// @param ipId The address identifier of the IP asset.\n    /// @param extraMetadata Additional metadata in bytes used by the new metadata provider.\n    function upgrade(address payable ipId, bytes memory extraMetadata) external;\n}\n"},"@story-protocol/protocol-core/contracts/registries/IPAccountRegistry.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { IERC6551Registry } from \"erc6551/interfaces/IERC6551Registry.sol\";\n\nimport { IIPAccountRegistry } from \"../interfaces/registries/IIPAccountRegistry.sol\";\nimport { Errors } from \"../lib/Errors.sol\";\n\n/// @title IPAccountRegistry\n/// @notice This contract is responsible for managing the registration and tracking of IP Accounts.\n/// It leverages a public ERC6551 registry to deploy IPAccount contracts.\ncontract IPAccountRegistry is IIPAccountRegistry {\n    /// @notice Returns the IPAccount implementation address\n    address public immutable IP_ACCOUNT_IMPL;\n\n    /// @notice Returns the IPAccount salt\n    bytes32 public immutable IP_ACCOUNT_SALT;\n\n    /// @notice Returns the public ERC6551 registry address\n    address public immutable ERC6551_PUBLIC_REGISTRY;\n\n    constructor(address erc6551Registry, address ipAccountImpl) {\n        if (ipAccountImpl == address(0)) revert Errors.IPAccountRegistry_InvalidIpAccountImpl();\n        IP_ACCOUNT_IMPL = ipAccountImpl;\n        IP_ACCOUNT_SALT = bytes32(0);\n        ERC6551_PUBLIC_REGISTRY = erc6551Registry;\n    }\n\n    /// @notice Deploys an IPAccount contract with the IPAccount implementation and returns the address of the new IP\n    /// @dev The IPAccount deployment deltegates to public ERC6551 Registry\n    /// @param chainId The chain ID where the IP Account will be created\n    /// @param tokenContract The address of the token contract to be associated with the IP Account\n    /// @param tokenId The ID of the token to be associated with the IP Account\n    /// @return ipAccountAddress The address of the newly created IP Account\n    function registerIpAccount(\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) public returns (address ipAccountAddress) {\n        ipAccountAddress = IERC6551Registry(ERC6551_PUBLIC_REGISTRY).createAccount(\n            IP_ACCOUNT_IMPL,\n            IP_ACCOUNT_SALT,\n            chainId,\n            tokenContract,\n            tokenId\n        );\n        emit IPAccountRegistered(ipAccountAddress, IP_ACCOUNT_IMPL, chainId, tokenContract, tokenId);\n    }\n\n    /// @notice Returns the IPAccount address for the given NFT token.\n    /// @param chainId The chain ID where the IP Account is located\n    /// @param tokenContract The address of the token contract associated with the IP Account\n    /// @param tokenId The ID of the token associated with the IP Account\n    /// @return ipAccountAddress The address of the IP Account associated with the given NFT token\n    function ipAccount(uint256 chainId, address tokenContract, uint256 tokenId) public view returns (address) {\n        return _get6551AccountAddress(chainId, tokenContract, tokenId);\n    }\n\n    /// @notice Returns the IPAccount implementation address.\n    /// @return The address of the IPAccount implementation\n    function getIPAccountImpl() external view override returns (address) {\n        return IP_ACCOUNT_IMPL;\n    }\n\n    /// @dev Helper function to get the IPAccount address from the ERC6551 registry.\n    function _get6551AccountAddress(\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) internal view returns (address) {\n        return\n            IERC6551Registry(ERC6551_PUBLIC_REGISTRY).account(\n                IP_ACCOUNT_IMPL,\n                IP_ACCOUNT_SALT,\n                chainId,\n                tokenContract,\n                tokenId\n            );\n    }\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/IIPAccount.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { IERC721Receiver } from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport { IERC1155Receiver } from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport { IERC6551Account } from \"erc6551/interfaces/IERC6551Account.sol\";\n\n/// @title IIPAccount\n/// @dev IPAccount is a token-bound account that adopts the EIP-6551 standard.\n/// These accounts are deployed at deterministic addresses through the official 6551 account registry.\n/// As a deployed smart contract, IPAccount can store IP-related information,\n/// like ownership of other NFTs such as license NFT or Royalty NFT.\n/// IPAccount can interact with modules by making calls as a normal transaction sender.\n/// This allows for seamless operations on the state and data of IP.\n/// IPAccount is core identity for all actions.\ninterface IIPAccount is IERC6551Account, IERC721Receiver, IERC1155Receiver {\n    /// @notice Emitted when a transaction is executed.\n    /// @param to The recipient of the transaction.\n    /// @param value The amount of Ether sent.\n    /// @param data The data sent along with the transaction.\n    /// @param nonce The nonce of the transaction.\n    event Executed(address indexed to, uint256 value, bytes data, uint256 nonce);\n\n    /// @notice Emitted when a transaction is executed on behalf of the signer.\n    /// @param to The recipient of the transaction.\n    /// @param value The amount of Ether sent.\n    /// @param data The data sent along with the transaction.\n    /// @param nonce The nonce of the transaction.\n    /// @param deadline The deadline of the transaction signature.\n    /// @param signer The signer of the transaction.\n    /// @param signature The signature of the transaction, EIP-712 encoded.\n    event ExecutedWithSig(\n        address indexed to,\n        uint256 value,\n        bytes data,\n        uint256 nonce,\n        uint256 deadline,\n        address indexed signer,\n        bytes signature\n    );\n\n    /// @notice Returns the IPAccount's internal nonce for transaction ordering.\n    function state() external view returns (uint256);\n\n    /// @notice Returns the identifier of the non-fungible token which owns the account\n    /// @return chainId The EIP-155 ID of the chain the token exists on\n    /// @return tokenContract The contract address of the token\n    /// @return tokenId The ID of the token\n    function token() external view returns (uint256, address, uint256);\n\n    /// @notice Checks if the signer is valid for the given data\n    /// @param signer The signer to check\n    /// @param data The data to check against\n    /// @return The function selector if the signer is valid, 0 otherwise\n    function isValidSigner(address signer, bytes calldata data) external view returns (bytes4);\n\n    /// @notice Returns the owner of the IP Account.\n    /// @return owner The address of the owner.\n    function owner() external view returns (address);\n\n    /// @notice Executes a transaction from the IP Account on behalf of the signer.\n    /// @param to The recipient of the transaction.\n    /// @param value The amount of Ether to send.\n    /// @param data The data to send along with the transaction.\n    /// @param signer The signer of the transaction.\n    /// @param deadline The deadline of the transaction signature.\n    /// @param signature The signature of the transaction, EIP-712 encoded.\n    /// @return result The return data from the transaction.\n    function executeWithSig(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        address signer,\n        uint256 deadline,\n        bytes calldata signature\n    ) external payable returns (bytes memory);\n\n    /// @notice Executes a transaction from the IP Account.\n    /// @param to The recipient of the transaction.\n    /// @param value The amount of Ether to send.\n    /// @param data The data to send along with the transaction.\n    /// @return result The return data from the transaction.\n    function execute(address to, uint256 value, bytes calldata data) external payable returns (bytes memory);\n}\n"},"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"},"@openzeppelin/contracts/token/ERC721/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"},"@openzeppelin/contracts/utils/math/SignedMath.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"},"@openzeppelin/contracts/utils/math/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"},"@openzeppelin/contracts/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"},"@openzeppelin/contracts/interfaces/IERC4906.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4906.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\nimport {IERC721} from \"./IERC721.sol\";\n\n/// @title EIP-721 Metadata Update Extension\ninterface IERC4906 is IERC165, IERC721 {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n"},"@openzeppelin/contracts/interfaces/draft-IERC6093.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"},"@openzeppelin/contracts/utils/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"},"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"},"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFSubscriptionV2Plus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice The IVRFSubscriptionV2Plus interface defines the subscription\n/// @notice related methods implemented by the V2Plus coordinator.\ninterface IVRFSubscriptionV2Plus {\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint256 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint256 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint256 subId, address to) external;\n\n  /**\n   * @notice Accept subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint256 subId) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint256 subId, address newOwner) external;\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription with LINK, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   * @dev Note to fund the subscription with Native, use fundSubscriptionWithNative. Be sure\n   * @dev  to send Native with the call, for example:\n   * @dev COORDINATOR.fundSubscriptionWithNative{value: amount}(subId);\n   */\n  function createSubscription() external returns (uint256 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return nativeBalance - native balance of the subscription in wei.\n   * @return reqCount - Requests count of subscription.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(\n    uint256 subId\n  )\n    external\n    view\n    returns (uint96 balance, uint96 nativeBalance, uint64 reqCount, address owner, address[] memory consumers);\n\n  /*\n   * @notice Check to see if there exists a request commitment consumers\n   * for all consumers and keyhashes for a given sub.\n   * @param subId - ID of the subscription\n   * @return true if there exists at least one unfulfilled request for the subscription, false\n   * otherwise.\n   */\n  function pendingRequestExists(uint256 subId) external view returns (bool);\n\n  /**\n   * @notice Paginate through all active VRF subscriptions.\n   * @param startIndex index of the subscription to start from\n   * @param maxCount maximum number of subscriptions to return, 0 to return all\n   * @dev the order of IDs in the list is **not guaranteed**, therefore, if making successive calls, one\n   * @dev should consider keeping the blockheight constant to ensure a holistic picture of the contract state\n   */\n  function getActiveSubscriptionIds(uint256 startIndex, uint256 maxCount) external view returns (uint256[] memory);\n\n  /**\n   * @notice Fund a subscription with native.\n   * @param subId - ID of the subscription\n   * @notice This method expects msg.value to be greater than or equal to 0.\n   */\n  function fundSubscriptionWithNative(uint256 subId) external payable;\n}\n"},"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwnerWithProposal} from \"./ConfirmedOwnerWithProposal.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"},"@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFMigratableConsumerV2Plus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice The IVRFMigratableConsumerV2Plus interface defines the\n/// @notice method required to be implemented by all V2Plus consumers.\n/// @dev This interface is designed to be used in VRFConsumerBaseV2Plus.\ninterface IVRFMigratableConsumerV2Plus {\n  event CoordinatorSet(address vrfCoordinator);\n\n  /// @notice Sets the VRF Coordinator address\n  /// @notice This method should only be callable by the coordinator or contract owner\n  function setCoordinator(address vrfCoordinator) external;\n}\n"},"@story-protocol/protocol-core/contracts/access/AccessControlled.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { IAccessController } from \"../interfaces/IAccessController.sol\";\nimport { IPAccountChecker } from \"../lib/registries/IPAccountChecker.sol\";\nimport { IIPAccountRegistry } from \"../interfaces/registries/IIPAccountRegistry.sol\";\nimport { Errors } from \"../lib/Errors.sol\";\n\n/// @title AccessControlled\n/// @notice Provides a base contract for access control functionalities.\n/// @dev This abstract contract implements basic access control mechanisms with an emphasis\n/// on IP account verification and permission checks.\n/// It is designed to be used as a base contract for other contracts that require access control.\n/// It provides modifiers and functions to verify if the caller has the necessary permission\n/// and is a registered IP account.\nabstract contract AccessControlled {\n    using IPAccountChecker for IIPAccountRegistry;\n\n    /// @notice The IAccessController instance for permission checks.\n    IAccessController public immutable ACCESS_CONTROLLER;\n    /// @notice The IIPAccountRegistry instance for IP account verification.\n    IIPAccountRegistry public immutable IP_ACCOUNT_REGISTRY;\n\n    /// @dev Initializes the contract by setting the ACCESS_CONTROLLER and IP_ACCOUNT_REGISTRY addresses.\n    /// @param accessController The address of the AccessController contract.\n    /// @param ipAccountRegistry The address of the IPAccountRegistry contract.\n    constructor(address accessController, address ipAccountRegistry) {\n        if (accessController == address(0)) revert Errors.AccessControlled__ZeroAddress();\n        if (ipAccountRegistry == address(0)) revert Errors.AccessControlled__ZeroAddress();\n        ACCESS_CONTROLLER = IAccessController(accessController);\n        IP_ACCOUNT_REGISTRY = IIPAccountRegistry(ipAccountRegistry);\n    }\n\n    /// @notice Verifies that the caller has the necessary permission for the given IPAccount.\n    /// @dev Modifier that calls _verifyPermission to check if the provided IP account has the required permission.\n    /// modules can use this modifier to check if the caller has the necessary permission.\n    /// @param ipAccount The address of the IP account to verify.\n    modifier verifyPermission(address ipAccount) {\n        _verifyPermission(ipAccount);\n        _;\n    }\n\n    /// @notice Ensures that the caller is a registered IP account.\n    /// @dev Modifier that checks if the msg.sender is a registered IP account.\n    /// modules can use this modifier to check if the caller is a registered IP account.\n    /// so that enforce only registered IP Account can call the functions.\n    modifier onlyIpAccount() {\n        if (!IP_ACCOUNT_REGISTRY.isIpAccount(msg.sender)) {\n            revert Errors.AccessControlled__CallerIsNotIpAccount(msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Internal function to verify if the caller (msg.sender) has the required permission to execute\n    /// the function on provided ipAccount.\n    /// @param ipAccount The address of the IP account to verify.\n    function _verifyPermission(address ipAccount) internal view {\n        if (!IP_ACCOUNT_REGISTRY.isIpAccount(ipAccount)) {\n            revert Errors.AccessControlled__NotIpAccount(ipAccount);\n        }\n\n        if (msg.sender != ipAccount) {\n            // revert if the msg.sender does not have permission\n            ACCESS_CONTROLLER.checkPermission(ipAccount, msg.sender, address(this), msg.sig);\n        }\n    }\n\n    /// @dev Internal function to check if the caller (msg.sender) has the required permission to execute\n    /// the function on provided ipAccount, returning a boolean.\n    /// @param ipAccount The address of the IP account to check.\n    /// @return bool Returns true if the caller has permission, false otherwise.\n    function _hasPermission(address ipAccount) internal view returns (bool) {\n        if (!IP_ACCOUNT_REGISTRY.isIpAccount(ipAccount)) {\n            return false;\n        }\n\n        if (msg.sender == ipAccount) {\n            return true;\n        }\n\n        try ACCESS_CONTROLLER.checkPermission(ipAccount, msg.sender, address(this), msg.sig) {\n            return true;\n        } catch {\n            return false;\n        }\n    }\n}\n"},"@story-protocol/protocol-core/contracts/modules/BaseModule.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IModule } from \"../interfaces/modules/base/IModule.sol\";\n\n/// @title BaseModule\n/// @notice Base implementation for all modules in Story Protocol.\nabstract contract BaseModule is ERC165, IModule {\n    /// @notice IERC165 interface support.\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IModule).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/resolvers/IKeyValueResolver.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n/// @title Key Value Resolver Interface\ninterface IKeyValueResolver {\n    /// @notice Emits when a new key-value pair is set for the resolver.\n    event KeyValueSet(address indexed ipId, string indexed key, string value);\n\n    /// @notice Sets the string value for a specified key of an IP ID.\n    /// @dev Enforced to be only callable by users with valid permission to call on behalf of the ipId.\n    /// @param ipId The canonical identifier of the IP asset.\n    /// @param key The string parameter key to update.\n    /// @param val The value to set for the specified key.\n    function setValue(address ipId, string calldata key, string calldata val) external;\n\n    /// @notice Retrieves the string value associated with a key for an IP asset.\n    /// @param key The string parameter key to query.\n    /// @return value The value associated with the specified key.\n    function value(address ipId, string calldata key) external view returns (string memory);\n}\n"},"@story-protocol/protocol-core/contracts/registries/metadata/MetadataProviderBase.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { IIPAccount } from \"../../interfaces/IIPAccount.sol\";\nimport { IMetadataProvider } from \"../../interfaces/registries/metadata/IMetadataProvider.sol\";\nimport { IIPAssetRegistry } from \"../../interfaces/registries/IIPAssetRegistry.sol\";\nimport { IMetadataProviderMigratable } from \"../../interfaces/registries/metadata/IMetadataProviderMigratable.sol\";\nimport { Errors } from \"../../lib/Errors.sol\";\n\n/// @title IP Metadata Provider Base Contract\n/// @notice Metadata provider base contract for storing canonical IP metadata.\nabstract contract MetadataProviderBase is IMetadataProviderMigratable {\n    /// @notice Returns the protocol-wide IP asset registry.\n    IIPAssetRegistry public immutable IP_ASSET_REGISTRY;\n\n    /// @notice Returns the new metadata provider IP assets may migrate to.\n    IMetadataProvider public upgradeProvider;\n\n    /// @notice Maps IP assets (via their IP ID) to their canonical metadata.\n    mapping(address ip => bytes metadata) internal _ipMetadata;\n\n    /// @notice Restricts calls to only originate from a protocol-authorized caller.\n    modifier onlyIPAssetRegistry() {\n        if (msg.sender != address(IP_ASSET_REGISTRY)) {\n            revert Errors.MetadataProvider__Unauthorized();\n        }\n        _;\n    }\n\n    constructor(address ipAssetRegistry) {\n        IP_ASSET_REGISTRY = IIPAssetRegistry(ipAssetRegistry);\n    }\n\n    /// @notice Gets the metadata associated with an IP asset.\n    /// @param ipId The address identifier of the IP asset.\n    /// @return metadata The encoded metadata associated with the IP asset.\n    function getMetadata(address ipId) external view virtual override returns (bytes memory) {\n        return _ipMetadata[ipId];\n    }\n\n    /// @notice Sets a upgrade provider for users to migrate their metadata to.\n    /// @param provider The address of the new metadata provider to migrate to.\n    function setUpgradeProvider(address provider) external onlyIPAssetRegistry {\n        if (provider == address(0)) {\n            revert Errors.MetadataProvider__UpgradeProviderInvalid();\n        }\n        // TODO: We may want to add interface detection here if auth changes.\n        upgradeProvider = IMetadataProviderMigratable(provider);\n    }\n\n    /// @notice Updates the provider used by the IP asset, migrating existing metadata to the new provider, and adding\n    /// new metadata.\n    /// @param ipId The address identifier of the IP asset.\n    /// @param metadata Additional metadata in bytes used by the new metadata provider.\n    function upgrade(address payable ipId, bytes memory metadata) external override {\n        if (address(upgradeProvider) == address(0)) {\n            revert Errors.MetadataProvider__UpgradeUnavailable();\n        }\n        // TODO: Provide more flexible IPAsset authorization via access controller.\n        if (msg.sender != IIPAccount(ipId).owner()) {\n            revert Errors.MetadataProvider__IPAssetOwnerInvalid();\n        }\n        if (!_compatible(_ipMetadata[ipId], metadata)) {\n            revert Errors.MetadataProvider__MetadataNotCompatible();\n        }\n        IP_ASSET_REGISTRY.setMetadata(ipId, address(upgradeProvider), metadata);\n    }\n\n    /// @notice Sets the metadata associated with an IP asset.\n    /// @dev Enforced to be only callable by the IP asset registry.\n    /// @param ipId The address identifier of the IP asset.\n    /// @param metadata The metadata in bytes to associate with the IP asset.\n    function setMetadata(address ipId, bytes memory metadata) external virtual onlyIPAssetRegistry {\n        _verifyMetadata(metadata);\n        _ipMetadata[ipId] = metadata;\n        emit MetadataSet(ipId, metadata);\n    }\n\n    /// @dev Checks that the data conforms to the canonical metadata standards.\n    /// @param metadata The canonical metadata in bytes to verify.\n    function _verifyMetadata(bytes memory metadata) internal virtual;\n\n    /// @dev Checks whether two sets of metadata are compatible with one another.\n    /// @param m1 The first set of bytes metadata being compared.\n    /// @param m2 The second set of bytes metadata being compared.\n    function _compatible(bytes memory m1, bytes memory m2) internal pure virtual returns (bool);\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/registries/IIPAccountRegistry.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n/// @title Interface for IP Account Registry\n/// @notice This interface manages the registration and tracking of IP Accounts\ninterface IIPAccountRegistry {\n    /// @notice Event emitted when a new IP Account is created\n    /// @param account The address of the new IP Account\n    /// @param implementation The address of the IP Account implementation\n    /// @param chainId The chain ID where the token contract was deployed\n    /// @param tokenContract The address of the token contract associated with the IP Account\n    /// @param tokenId The ID of the token associated with the IP Account\n    event IPAccountRegistered(\n        address indexed account,\n        address indexed implementation,\n        uint256 indexed chainId,\n        address tokenContract,\n        uint256 tokenId\n    );\n\n    /// @notice Returns the IPAccount implementation address\n    function IP_ACCOUNT_IMPL() external view returns (address);\n\n    /// @notice Returns the IPAccount salt\n    function IP_ACCOUNT_SALT() external view returns (bytes32);\n\n    /// @notice Returns the public ERC6551 registry address\n    function ERC6551_PUBLIC_REGISTRY() external view returns (address);\n\n    /// @notice Deploys an IPAccount contract with the IPAccount implementation and returns the address of the new IP\n    /// @dev The IPAccount deployment deltegates to public ERC6551 Registry\n    /// @param chainId The chain ID where the IP Account will be created\n    /// @param tokenContract The address of the token contract to be associated with the IP Account\n    /// @param tokenId The ID of the token to be associated with the IP Account\n    /// @return ipAccountAddress The address of the newly created IP Account\n    function registerIpAccount(uint256 chainId, address tokenContract, uint256 tokenId) external returns (address);\n\n    /// @notice Returns the IPAccount address for the given NFT token.\n    /// @param chainId The chain ID where the IP Account is located\n    /// @param tokenContract The address of the token contract associated with the IP Account\n    /// @param tokenId The ID of the token associated with the IP Account\n    /// @return ipAccountAddress The address of the IP Account associated with the given NFT token\n    function ipAccount(uint256 chainId, address tokenContract, uint256 tokenId) external view returns (address);\n\n    /// @notice Returns the IPAccount implementation address.\n    /// @return The address of the IPAccount implementation\n    function getIPAccountImpl() external view returns (address);\n}\n"},"erc6551/interfaces/IERC6551Registry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC6551Registry {\n    /**\n     * @dev The registry MUST emit the ERC6551AccountCreated event upon successful account creation.\n     */\n    event ERC6551AccountCreated(\n        address account,\n        address indexed implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address indexed tokenContract,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev The registry MUST revert with AccountCreationFailed error if the create2 operation fails.\n     */\n    error AccountCreationFailed();\n\n    /**\n     * @dev Creates a token bound account for a non-fungible token.\n     *\n     * If account has already been created, returns the account address without calling create2.\n     *\n     * Emits ERC6551AccountCreated event.\n     *\n     * @return account The address of the token bound account\n     */\n    function createAccount(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) external returns (address account);\n\n    /**\n     * @dev Returns the computed token bound account address for a non-fungible token.\n     *\n     * @return account The address of the token bound account\n     */\n    function account(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) external view returns (address account);\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/registries/metadata/IMetadataProvider.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n/// @title Metadata Provider Interface\ninterface IMetadataProvider {\n    /// @notice Emits when canonical metadata was set for a specific IP asset.\n    /// @param ipId The address of the IP asset.\n    /// @param metadata The encoded metadata associated with the IP asset.\n    event MetadataSet(address ipId, bytes metadata);\n\n    /// @notice Gets the metadata associated with an IP asset.\n    /// @param ipId The address identifier of the IP asset.\n    /// @return metadata The encoded metadata associated with the IP asset.\n    function getMetadata(address ipId) external view returns (bytes memory);\n\n    /// @notice Sets the metadata associated with an IP asset.\n    /// @param ipId The address identifier of the IP asset.\n    /// @param metadata The metadata in bytes to associate with the IP asset.\n    function setMetadata(address ipId, bytes memory metadata) external;\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/modules/dispute/IDisputeModule.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n/// @title Dispute Module Interface\ninterface IDisputeModule {\n    /// @notice Dispute struct\n    /// @param targetIpId The ipId that is the target of the dispute\n    /// @param disputeInitiator The address of the dispute initiator\n    /// @param arbitrationPolicy The address of the arbitration policy\n    /// @param linkToDisputeEvidence The link of the dispute evidence\n    /// @param targetTag The target tag of the dispute\n    /// @param currentTag The current tag of the dispute\n    struct Dispute {\n        address targetIpId;\n        address disputeInitiator;\n        address arbitrationPolicy;\n        bytes32 linkToDisputeEvidence;\n        bytes32 targetTag;\n        bytes32 currentTag;\n    }\n\n    /// @notice Event emitted when a dispute tag whitelist status is updated\n    /// @param tag The dispute tag\n    /// @param allowed Indicates if the dispute tag is whitelisted\n    event TagWhitelistUpdated(bytes32 tag, bool allowed);\n\n    /// @notice Event emitted when an arbitration policy whitelist status is updated\n    /// @param arbitrationPolicy The address of the arbitration policy\n    /// @param allowed Indicates if the arbitration policy is whitelisted\n    event ArbitrationPolicyWhitelistUpdated(address arbitrationPolicy, bool allowed);\n\n    /// @notice Event emitted when an arbitration relayer whitelist status is updated\n    /// @param arbitrationPolicy The address of the arbitration policy\n    /// @param arbitrationRelayer The address of the arbitration relayer\n    /// @param allowed Indicates if the arbitration relayer is whitelisted\n    event ArbitrationRelayerWhitelistUpdated(address arbitrationPolicy, address arbitrationRelayer, bool allowed);\n\n    /// @notice Event emitted when the base arbitration policy is set\n    /// @param arbitrationPolicy The address of the arbitration policy\n    event DefaultArbitrationPolicyUpdated(address arbitrationPolicy);\n\n    /// @notice Event emitted when an arbitration policy is set for an ipId\n    /// @param ipId The ipId address\n    /// @param arbitrationPolicy The address of the arbitration policy\n    event ArbitrationPolicySet(address ipId, address arbitrationPolicy);\n\n    /// @notice Event emitted when a dispute is raised\n    /// @param disputeId The dispute id\n    /// @param targetIpId The ipId that is the target of the dispute\n    /// @param disputeInitiator The address of the dispute initiator\n    /// @param arbitrationPolicy The address of the arbitration policy\n    /// @param linkToDisputeEvidence The link of the dispute evidence\n    /// @param targetTag The target tag of the dispute\n    /// @param data Custom data adjusted to each policy\n    event DisputeRaised(\n        uint256 disputeId,\n        address targetIpId,\n        address disputeInitiator,\n        address arbitrationPolicy,\n        bytes32 linkToDisputeEvidence,\n        bytes32 targetTag,\n        bytes data\n    );\n\n    /// @notice Event emitted when a dispute judgement is set\n    /// @param disputeId The dispute id\n    /// @param decision The decision of the dispute\n    /// @param data Custom data adjusted to each policy\n    event DisputeJudgementSet(uint256 disputeId, bool decision, bytes data);\n\n    /// @notice Event emitted when a dispute is cancelled\n    /// @param disputeId The dispute id\n    /// @param data Custom data adjusted to each policy\n    event DisputeCancelled(uint256 disputeId, bytes data);\n\n    /// @notice Event emitted when a dispute is resolved\n    /// @param disputeId The dispute id\n    event DisputeResolved(uint256 disputeId);\n\n    /// @notice Tag to represent the dispute is in dispute state waiting for judgement\n    function IN_DISPUTE() external view returns (bytes32);\n\n    /// @notice Dispute ID counter\n    function disputeCounter() external view returns (uint256);\n\n    /// @notice The address of the base arbitration policy\n    function baseArbitrationPolicy() external view returns (address);\n\n    /// @notice Returns the dispute information for a given dispute id\n    /// @param disputeId The dispute id\n    /// @return targetIpId The ipId that is the target of the dispute\n    /// @return disputeInitiator The address of the dispute initiator\n    /// @return arbitrationPolicy The address of the arbitration policy\n    /// @return linkToDisputeEvidence The link of the dispute summary\n    /// @return targetTag The target tag of the dispute\n    /// @return currentTag The current tag of the dispute\n    function disputes(\n        uint256 disputeId\n    )\n        external\n        view\n        returns (\n            address targetIpId,\n            address disputeInitiator,\n            address arbitrationPolicy,\n            bytes32 linkToDisputeEvidence,\n            bytes32 targetTag,\n            bytes32 currentTag\n        );\n\n    /// @notice Indicates if a dispute tag is whitelisted\n    /// @param tag The dispute tag\n    /// @return allowed Indicates if the dispute tag is whitelisted\n    function isWhitelistedDisputeTag(bytes32 tag) external view returns (bool allowed);\n\n    /// @notice Indicates if an arbitration policy is whitelisted\n    /// @param arbitrationPolicy The address of the arbitration policy\n    /// @return allowed Indicates if the arbitration policy is whitelisted\n    function isWhitelistedArbitrationPolicy(address arbitrationPolicy) external view returns (bool allowed);\n\n    /// @notice Indicates if an arbitration relayer is whitelisted for a given arbitration policy\n    /// @param arbitrationPolicy The address of the arbitration policy\n    /// @param arbitrationRelayer The address of the arbitration relayer\n    /// @return allowed Indicates if the arbitration relayer is whitelisted\n    function isWhitelistedArbitrationRelayer(\n        address arbitrationPolicy,\n        address arbitrationRelayer\n    ) external view returns (bool allowed);\n\n    /// @notice Arbitration policy for a given ipId\n    /// @param ipId The ipId\n    /// @return policy The address of the arbitration policy\n    function arbitrationPolicies(address ipId) external view returns (address policy);\n\n    /// @notice Whitelists a dispute tag\n    /// @param tag The dispute tag\n    /// @param allowed Indicates if the dispute tag is whitelisted or not\n    function whitelistDisputeTag(bytes32 tag, bool allowed) external;\n\n    /// @notice Whitelists an arbitration policy\n    /// @param arbitrationPolicy The address of the arbitration policy\n    /// @param allowed Indicates if the arbitration policy is whitelisted or not\n    function whitelistArbitrationPolicy(address arbitrationPolicy, bool allowed) external;\n\n    /// @notice Whitelists an arbitration relayer for a given arbitration policy\n    /// @param arbitrationPolicy The address of the arbitration policy\n    /// @param arbPolicyRelayer The address of the arbitration relayer\n    /// @param allowed Indicates if the arbitration relayer is whitelisted or not\n    function whitelistArbitrationRelayer(address arbitrationPolicy, address arbPolicyRelayer, bool allowed) external;\n\n    /// @notice Sets the base arbitration policy\n    /// @param arbitrationPolicy The address of the arbitration policy\n    function setBaseArbitrationPolicy(address arbitrationPolicy) external;\n\n    /// @notice Sets the arbitration policy for an ipId\n    /// @param ipId The ipId\n    /// @param arbitrationPolicy The address of the arbitration policy\n    function setArbitrationPolicy(address ipId, address arbitrationPolicy) external;\n\n    /// @notice Raises a dispute on a given ipId\n    /// @param targetIpId The ipId that is the target of the dispute\n    /// @param linkToDisputeEvidence The link of the dispute evidence\n    /// @param targetTag The target tag of the dispute\n    /// @param data The data to initialize the policy\n    /// @return disputeId The id of the newly raised dispute\n    function raiseDispute(\n        address targetIpId,\n        string memory linkToDisputeEvidence,\n        bytes32 targetTag,\n        bytes calldata data\n    ) external returns (uint256 disputeId);\n\n    /// @notice Sets the dispute judgement on a given dispute. Only whitelisted arbitration relayers can call to judge.\n    /// @param disputeId The dispute id\n    /// @param decision The decision of the dispute\n    /// @param data The data to set the dispute judgement\n    function setDisputeJudgement(uint256 disputeId, bool decision, bytes calldata data) external;\n\n    /// @notice Cancels an ongoing dispute\n    /// @param disputeId The dispute id\n    /// @param data The data to cancel the dispute\n    function cancelDispute(uint256 disputeId, bytes calldata data) external;\n\n    /// @notice Resolves a dispute after it has been judged\n    /// @param disputeId The dispute id\n    function resolveDispute(uint256 disputeId) external;\n\n    /// @notice Returns true if the ipId is tagged with any tag (meaning at least one dispute went through)\n    /// @param ipId The ipId\n    /// @return isTagged True if the ipId is tagged\n    function isIpTagged(address ipId) external view returns (bool);\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/registries/ILicenseRegistry.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport { Licensing } from \"../../lib/Licensing.sol\";\nimport { IDisputeModule } from \"../modules/dispute/IDisputeModule.sol\";\nimport { ILicensingModule } from \"../modules/licensing/ILicensingModule.sol\";\n\n/// @title ILicenseRegistry\ninterface ILicenseRegistry is IERC1155 {\n    /// @notice Emitted when a license is minted\n    /// @param creator The address that created the license\n    /// @param receiver The address that received the license\n    /// @param licenseId The ID of the license\n    /// @param amount The amount of licenses minted\n    /// @param licenseData The license data\n    event LicenseMinted(\n        address indexed creator,\n        address indexed receiver,\n        uint256 indexed licenseId,\n        uint256 amount,\n        Licensing.License licenseData\n    );\n\n    /// @notice Returns the canonical protocol-wide LicensingModule\n    function LICENSING_MODULE() external view returns (ILicensingModule);\n\n    /// @notice Returns the canonical protocol-wide DisputeModule\n    function DISPUTE_MODULE() external view returns (IDisputeModule);\n\n    /// @notice Mints license NFTs representing a policy granted by a set of ipIds (licensors). This NFT needs to be\n    /// burned in order to link a derivative IP with its parents. If this is the first combination of policy and\n    /// licensors, a new licenseId will be created. If not, the license is fungible and an id will be reused.\n    /// @dev Only callable by the licensing module.\n    /// @param policyId The ID of the policy to be minted\n    /// @param licensorIpId_ The ID of the IP granting the license (ie. licensor)\n    /// @param transferable True if the license is transferable\n    /// @param amount Number of licenses to mint. License NFT is fungible for same policy and same licensors\n    /// @param receiver Receiver address of the minted license NFT(s).\n    /// @return licenseId The ID of the minted license NFT(s).\n    function mintLicense(\n        uint256 policyId,\n        address licensorIpId_,\n        bool transferable,\n        uint256 amount,\n        address receiver\n    ) external returns (uint256 licenseId);\n\n    /// @notice Burns licenses\n    /// @param holder The address that holds the licenses\n    /// @param licenseIds The ids of the licenses to burn\n    function burnLicenses(address holder, uint256[] calldata licenseIds) external;\n\n    ///\n    /// Getters\n    ///\n\n    /// @notice Returns the number of licenses registered in the protocol.\n    /// @dev Token ID counter total count.\n    /// @return mintedLicenses The number of minted licenses\n    function mintedLicenses() external view returns (uint256);\n\n    /// @notice Returns true if holder has positive balance for the given license ID.\n    /// @return isLicensee True if holder is the licensee for the license (owner of the license NFT), or derivative IP\n    /// owner if the license was added to the IP by linking (burning a license).\n    function isLicensee(uint256 licenseId, address holder) external view returns (bool);\n\n    /// @notice Returns the license data for the given license ID\n    /// @param licenseId The ID of the license\n    /// @return licenseData The license data\n    function license(uint256 licenseId) external view returns (Licensing.License memory);\n\n    /// @notice Returns the ID of the IP asset that is the licensor of the given license ID\n    /// @param licenseId The ID of the license\n    /// @return licensorIpId The ID of the licensor\n    function licensorIpId(uint256 licenseId) external view returns (address);\n\n    /// @notice Returns the policy ID for the given license ID\n    /// @param licenseId The ID of the license\n    /// @return policyId The ID of the policy\n    function policyIdForLicense(uint256 licenseId) external view returns (uint256);\n\n    /// @notice Returns true if the license has been revoked (licensor tagged after a dispute in\n    /// the dispute module). If the tag is removed, the license is not revoked anymore.\n    /// @param licenseId The id of the license to check\n    /// @return isRevoked True if the license is revoked\n    function isLicenseRevoked(uint256 licenseId) external view returns (bool);\n}\n"},"@story-protocol/protocol-core/contracts/modules/royalty/RoyaltyModule.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { BaseModule } from \"../BaseModule.sol\";\nimport { Governable } from \"../../governance/Governable.sol\";\nimport { IRoyaltyModule } from \"../../interfaces/modules/royalty/IRoyaltyModule.sol\";\nimport { IRoyaltyPolicy } from \"../../interfaces/modules/royalty/policies/IRoyaltyPolicy.sol\";\nimport { Errors } from \"../../lib/Errors.sol\";\nimport { ROYALTY_MODULE_KEY } from \"../../lib/modules/Module.sol\";\nimport { BaseModule } from \"../BaseModule.sol\";\n\n/// @title Story Protocol Royalty Module\n/// @notice The Story Protocol royalty module allows to set royalty policies an IP asset and pay royalties as a\n///         derivative IP.\ncontract RoyaltyModule is IRoyaltyModule, Governable, ReentrancyGuard, BaseModule {\n    using ERC165Checker for address;\n\n    string public constant override name = ROYALTY_MODULE_KEY;\n\n    /// @notice Returns the licensing module address\n    address public LICENSING_MODULE;\n\n    /// @notice Indicates if a royalty policy is whitelisted\n    mapping(address royaltyPolicy => bool isWhitelisted) public isWhitelistedRoyaltyPolicy;\n\n    /// @notice Indicates if a royalty token is whitelisted\n    mapping(address token => bool) public isWhitelistedRoyaltyToken;\n\n    /// @notice Indicates the royalty policy for a given IP asset\n    mapping(address ipId => address royaltyPolicy) public royaltyPolicies;\n\n    constructor(address governance) Governable(governance) {}\n\n    /// @notice Modifier to enforce that the caller is the licensing module\n    modifier onlyLicensingModule() {\n        if (msg.sender != LICENSING_MODULE) revert Errors.RoyaltyModule__NotAllowedCaller();\n        _;\n    }\n\n    /// @notice Sets the license registry\n    /// @dev Enforced to be only callable by the protocol admin\n    /// @param licensingModule The address of the license registry\n    function setLicensingModule(address licensingModule) external onlyProtocolAdmin {\n        if (licensingModule == address(0)) revert Errors.RoyaltyModule__ZeroLicensingModule();\n        LICENSING_MODULE = licensingModule;\n    }\n\n    /// @notice Whitelist a royalty policy\n    /// @dev Enforced to be only callable by the protocol admin\n    /// @param royaltyPolicy The address of the royalty policy\n    /// @param allowed Indicates if the royalty policy is whitelisted or not\n    function whitelistRoyaltyPolicy(address royaltyPolicy, bool allowed) external onlyProtocolAdmin {\n        if (royaltyPolicy == address(0)) revert Errors.RoyaltyModule__ZeroRoyaltyPolicy();\n\n        isWhitelistedRoyaltyPolicy[royaltyPolicy] = allowed;\n\n        emit RoyaltyPolicyWhitelistUpdated(royaltyPolicy, allowed);\n    }\n\n    /// @notice Whitelist a royalty token\n    /// @dev Enforced to be only callable by the protocol admin\n    /// @param token The token address\n    /// @param allowed Indicates if the token is whitelisted or not\n    function whitelistRoyaltyToken(address token, bool allowed) external onlyProtocolAdmin {\n        if (token == address(0)) revert Errors.RoyaltyModule__ZeroRoyaltyToken();\n\n        isWhitelistedRoyaltyToken[token] = allowed;\n\n        emit RoyaltyTokenWhitelistUpdated(token, allowed);\n    }\n\n    /// @notice Executes royalty related logic on license minting\n    /// @dev Enforced to be only callable by LicensingModule\n    /// @param ipId The ipId whose license is being minted (licensor)\n    /// @param royaltyPolicy The royalty policy address of the license being minted\n    /// @param licenseData The license data custom to each the royalty policy\n    /// @param externalData The external data custom to each the royalty policy\n    function onLicenseMinting(\n        address ipId,\n        address royaltyPolicy,\n        bytes calldata licenseData,\n        bytes calldata externalData\n    ) external nonReentrant onlyLicensingModule {\n        if (!isWhitelistedRoyaltyPolicy[royaltyPolicy]) revert Errors.RoyaltyModule__NotWhitelistedRoyaltyPolicy();\n\n        address royaltyPolicyIpId = royaltyPolicies[ipId];\n\n        // if the node is a root node, then royaltyPolicyIpId will be address(0) and any type of royalty type can be\n        // selected to mint a license if the node is a derivative node, then the any minted licenses by the derivative\n        // node should have the same royalty policy as the parent node a derivative node set its royalty policy\n        // immutably in onLinkToParents() function below\n        if (royaltyPolicyIpId != royaltyPolicy && royaltyPolicyIpId != address(0))\n            revert Errors.RoyaltyModule__CanOnlyMintSelectedPolicy();\n\n        IRoyaltyPolicy(royaltyPolicy).onLicenseMinting(ipId, licenseData, externalData);\n    }\n\n    /// @notice Executes royalty related logic on linking to parents\n    /// @dev Enforced to be only callable by LicensingModule\n    /// @param ipId The children ipId that is being linked to parents\n    /// @param royaltyPolicy The common royalty policy address of all the licenses being burned\n    /// @param parentIpIds The parent ipIds that the children ipId is being linked to\n    /// @param licenseData The license data custom to each the royalty policy\n    /// @param externalData The external data custom to each the royalty policy\n    function onLinkToParents(\n        address ipId,\n        address royaltyPolicy,\n        address[] calldata parentIpIds,\n        bytes[] memory licenseData,\n        bytes calldata externalData\n    ) external nonReentrant onlyLicensingModule {\n        if (!isWhitelistedRoyaltyPolicy[royaltyPolicy]) revert Errors.RoyaltyModule__NotWhitelistedRoyaltyPolicy();\n        if (parentIpIds.length == 0) revert Errors.RoyaltyModule__NoParentsOnLinking();\n\n        for (uint32 i = 0; i < parentIpIds.length; i++) {\n            address parentRoyaltyPolicy = royaltyPolicies[parentIpIds[i]];\n            // if the parent node has a royalty policy set, then the derivative node should have the same royalty\n            // policy if the parent node does not have a royalty policy set, then the derivative node can set any type\n            // of royalty policy as long as the children ip obtained and is burning all licenses with that royalty type\n            // from each parent (was checked in licensing module before calling this function)\n            if (parentRoyaltyPolicy != royaltyPolicy && parentRoyaltyPolicy != address(0))\n                revert Errors.RoyaltyModule__IncompatibleRoyaltyPolicy();\n        }\n\n        royaltyPolicies[ipId] = royaltyPolicy;\n\n        IRoyaltyPolicy(royaltyPolicy).onLinkToParents(ipId, parentIpIds, licenseData, externalData);\n    }\n\n    /// @notice Allows the function caller to pay royalties to the receiver IP asset on behalf of the payer IP asset.\n    /// @param receiverIpId The ipId that receives the royalties\n    /// @param payerIpId The ipId that pays the royalties\n    /// @param token The token to use to pay the royalties\n    /// @param amount The amount to pay\n    function payRoyaltyOnBehalf(\n        address receiverIpId,\n        address payerIpId,\n        address token,\n        uint256 amount\n    ) external nonReentrant {\n        if (!isWhitelistedRoyaltyToken[token]) revert Errors.RoyaltyModule__NotWhitelistedRoyaltyToken();\n\n        address payerRoyaltyPolicy = royaltyPolicies[payerIpId];\n        // if the payer does not have a royalty policy set, then the payer is not a derivative ip and does not pay\n        // royalties the receiver ip can have a zero royalty policy since that could mean it is an ip a root\n        if (payerRoyaltyPolicy == address(0)) revert Errors.RoyaltyModule__NoRoyaltyPolicySet();\n        if (!isWhitelistedRoyaltyPolicy[payerRoyaltyPolicy]) revert Errors.RoyaltyModule__NotWhitelistedRoyaltyPolicy();\n\n        IRoyaltyPolicy(payerRoyaltyPolicy).onRoyaltyPayment(msg.sender, receiverIpId, token, amount);\n\n        emit RoyaltyPaid(receiverIpId, payerIpId, msg.sender, token, amount);\n    }\n\n    /// @notice Allows to pay the minting fee for a license\n    /// @param receiverIpId The ipId that receives the royalties\n    /// @param payerAddress The address that pays the royalties\n    /// @param licenseRoyaltyPolicy The royalty policy of the license being minted\n    /// @param token The token to use to pay the royalties\n    /// @param amount The amount to pay\n    function payLicenseMintingFee(\n        address receiverIpId,\n        address payerAddress,\n        address licenseRoyaltyPolicy,\n        address token,\n        uint256 amount\n    ) external onlyLicensingModule {\n        if (!isWhitelistedRoyaltyToken[token]) revert Errors.RoyaltyModule__NotWhitelistedRoyaltyToken();\n\n        if (licenseRoyaltyPolicy == address(0)) revert Errors.RoyaltyModule__NoRoyaltyPolicySet();\n        if (!isWhitelistedRoyaltyPolicy[licenseRoyaltyPolicy])\n            revert Errors.RoyaltyModule__NotWhitelistedRoyaltyPolicy();\n\n        IRoyaltyPolicy(licenseRoyaltyPolicy).onRoyaltyPayment(payerAddress, receiverIpId, token, amount);\n\n        emit LicenseMintingFeePaid(receiverIpId, payerAddress, token, amount);\n    }\n\n    /// @notice IERC165 interface support.\n    function supportsInterface(bytes4 interfaceId) public view virtual override(BaseModule, IERC165) returns (bool) {\n        return interfaceId == type(IRoyaltyModule).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/modules/base/IModule.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/// @notice Module Interface\ninterface IModule is IERC165 {\n    /// @notice Returns the string identifier associated with the module.\n    function name() external returns (string memory);\n}\n"},"@story-protocol/protocol-core/contracts/lib/Licensing.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n/// @title Licensing\n/// @notice Types and constants used by the licensing related contracts\nlibrary Licensing {\n    /// @notice A particular configuration (flavor) of a Policy Framework, setting values for the licensing\n    /// terms (parameters) of the framework.\n    /// @param isLicenseTransferable Whether or not the license is transferable\n    /// @param policyFramework address of the IPolicyFrameworkManager this policy is based on\n    /// @param frameworkData Data to be used by the policy framework to verify minting and linking\n    /// @param royaltyPolicy address of the royalty policy to be used by the policy framework, if any\n    /// @param royaltyData Data to be used by the royalty policy (for example, encoding of the royalty percentage)\n    /// @param mintingFee Fee to be paid when minting a license\n    /// @param mintingFeeToken Token to be used to pay the minting fee\n    struct Policy {\n        bool isLicenseTransferable;\n        address policyFramework;\n        bytes frameworkData;\n        address royaltyPolicy;\n        bytes royaltyData;\n        uint256 mintingFee;\n        address mintingFeeToken;\n    }\n\n    /// @notice Data that define a License Agreement NFT\n    /// @param policyId Id of the policy this license is based on, which will be set in the derivative IP when the\n    /// license is burnt for linking\n    /// @param licensorIpId Id of the IP this license is for\n    /// @param transferable Whether or not the license is transferable\n    struct License {\n        uint256 policyId;\n        address licensorIpId;\n        bool transferable;\n        // TODO: support for transfer hooks\n    }\n}\n"},"erc6551/interfaces/IERC6551Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @dev the ERC-165 identifier for this interface is `0x6faff5f1`\ninterface IERC6551Account {\n    /**\n     * @dev Allows the account to receive Ether.\n     *\n     * Accounts MUST implement a `receive` function.\n     *\n     * Accounts MAY perform arbitrary logic to restrict conditions\n     * under which Ether can be received.\n     */\n    receive() external payable;\n\n    /**\n     * @dev Returns the identifier of the non-fungible token which owns the account.\n     *\n     * The return value of this function MUST be constant - it MUST NOT change over time.\n     *\n     * @return chainId       The EIP-155 ID of the chain the token exists on\n     * @return tokenContract The contract address of the token\n     * @return tokenId       The ID of the token\n     */\n    function token()\n        external\n        view\n        returns (uint256 chainId, address tokenContract, uint256 tokenId);\n\n    /**\n     * @dev Returns a value that SHOULD be modified each time the account changes state.\n     *\n     * @return The current account state\n     */\n    function state() external view returns (uint256);\n\n    /**\n     * @dev Returns a magic value indicating whether a given signer is authorized to act on behalf\n     * of the account.\n     *\n     * MUST return the bytes4 magic value 0x523e3260 if the given signer is valid.\n     *\n     * By default, the holder of the non-fungible token the account is bound to MUST be considered\n     * a valid signer.\n     *\n     * Accounts MAY implement additional authorization logic which invalidates the holder as a\n     * signer or grants signing permissions to other non-holder accounts.\n     *\n     * @param  signer     The address to check signing authorization for\n     * @param  context    Additional data used to determine whether the signer is valid\n     * @return magicValue Magic value indicating whether the signer is valid\n     */\n    function isValidSigner(address signer, bytes calldata context)\n        external\n        view\n        returns (bytes4 magicValue);\n}\n"},"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"@story-protocol/protocol-core/contracts/lib/GovernanceLib.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n/// @title Governance\n/// @dev This library provides types for Story Protocol Governance.\nlibrary GovernanceLib {\n    bytes32 public constant PROTOCOL_ADMIN = bytes32(0);\n\n    /// @notice An enum containing the different states the protocol can be in.\n    /// @param Unpaused The unpaused state.\n    /// @param Paused The paused state.\n    enum ProtocolState {\n        Unpaused,\n        Paused\n    }\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/governance/IGovernable.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n/// @title IGovernable\n/// @notice This is the interface for the Lens Protocol main governance functions.\ninterface IGovernable {\n    /// @notice Emitted when the governance is updated\n    /// @param newGovernance The address of the new governance\n    event GovernanceUpdated(address indexed newGovernance);\n\n    /// @notice Sets the governance address\n    /// @param newGovernance The address of the new governance\n    function setGovernance(address newGovernance) external;\n\n    /// @notice Returns the current governance address\n    /// @return The address of the current governance\n    function getGovernance() external view returns (address);\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/governance/IGovernance.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { IAccessControl } from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport { GovernanceLib } from \"../../lib/GovernanceLib.sol\";\n\n/// @title IGovernance\n/// @dev This interface defines the governance functionality for the protocol.\ninterface IGovernance is IAccessControl {\n    /// @notice Emitted when the protocol state is set\n    /// @param account The address that triggered the state change\n    /// @param prevState The previous state of the protocol\n    /// @param newState The new state of the protocol\n    /// @param timestamp The time when the state change occurred\n    event StateSet(\n        address indexed account,\n        GovernanceLib.ProtocolState prevState,\n        GovernanceLib.ProtocolState newState,\n        uint256 timestamp\n    );\n\n    /// @notice Sets the state of the protocol\n    /// @dev This function can only be called by an account with the appropriate role\n    /// @param newState The new state to set for the protocol\n    function setState(GovernanceLib.ProtocolState newState) external;\n\n    /// @notice Returns the current state of the protocol\n    /// @return state The current state of the protocol\n    function getState() external view returns (GovernanceLib.ProtocolState);\n}\n"},"@openzeppelin/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"@openzeppelin/contracts/interfaces/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../token/ERC721/IERC721.sol\";\n"},"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    // solhint-disable-next-line gas-custom-errors\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  function _transferOwnership(address to) private {\n    // solhint-disable-next-line gas-custom-errors\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/modules/royalty/policies/IRoyaltyPolicy.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n/// @title RoyaltyPolicy interface\ninterface IRoyaltyPolicy {\n    /// @notice Executes royalty related logic on minting a license\n    /// @dev Enforced to be only callable by RoyaltyModule\n    /// @param ipId The ipId whose license is being minted (licensor)\n    /// @param licenseData The license data custom to each the royalty policy\n    /// @param externalData The external data custom to each the royalty policy\n    function onLicenseMinting(address ipId, bytes calldata licenseData, bytes calldata externalData) external;\n\n    /// @notice Executes royalty related logic on linking to parents\n    /// @dev Enforced to be only callable by RoyaltyModule\n    /// @param ipId The children ipId that is being linked to parents\n    /// @param parentIpIds The parent ipIds that the children ipId is being linked to\n    /// @param licenseData The license data custom to each the royalty policy\n    /// @param externalData The external data custom to each the royalty policy\n    function onLinkToParents(\n        address ipId,\n        address[] calldata parentIpIds,\n        bytes[] memory licenseData,\n        bytes calldata externalData\n    ) external;\n\n    /// @notice Allows the caller to pay royalties to the given IP asset\n    /// @param caller The caller is the address from which funds will transferred from\n    /// @param ipId The ipId of the receiver of the royalties\n    /// @param token The token to pay\n    /// @param amount The amount to pay\n    function onRoyaltyPayment(address caller, address ipId, address token, uint256 amount) external;\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/modules/royalty/IRoyaltyModule.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { IModule } from \"../../modules/base/IModule.sol\";\n\n/// @title RoyaltyModule interface\ninterface IRoyaltyModule is IModule {\n    /// @notice Event emitted when a royalty policy is whitelisted\n    /// @param royaltyPolicy The address of the royalty policy\n    /// @param allowed Indicates if the royalty policy is whitelisted or not\n    event RoyaltyPolicyWhitelistUpdated(address royaltyPolicy, bool allowed);\n\n    /// @notice Event emitted when a royalty token is whitelisted\n    /// @param token The address of the royalty token\n    /// @param allowed Indicates if the royalty token is whitelisted or not\n    event RoyaltyTokenWhitelistUpdated(address token, bool allowed);\n\n    /// @notice Event emitted when royalties are paid\n    /// @param receiverIpId The ID of IP asset that receives the royalties\n    /// @param payerIpId The ID of IP asset that pays the royalties\n    /// @param sender The address that pays the royalties on behalf of the payer ID of IP asset\n    /// @param token The token that is used to pay the royalties\n    /// @param amount The amount that is paid\n    event RoyaltyPaid(address receiverIpId, address payerIpId, address sender, address token, uint256 amount);\n\n    /// @notice Event emitted when the license minting fee is paid\n    /// @param receiverIpId The ipId that receives the royalties\n    /// @param payerAddress The address that pays the royalties\n    /// @param token The token that is used to pay the royalties\n    /// @param amount The amount paid\n    event LicenseMintingFeePaid(address receiverIpId, address payerAddress, address token, uint256 amount);\n\n    /// @notice Returns the licensing module address\n    function LICENSING_MODULE() external view returns (address);\n\n    /// @notice Indicates if a royalty policy is whitelisted\n    /// @param royaltyPolicy The address of the royalty policy\n    /// @return isWhitelisted True if the royalty policy is whitelisted\n    function isWhitelistedRoyaltyPolicy(address royaltyPolicy) external view returns (bool);\n\n    /// @notice Indicates if a royalty token is whitelisted\n    /// @param token The address of the royalty token\n    /// @return isWhitelisted True if the royalty token is whitelisted\n    function isWhitelistedRoyaltyToken(address token) external view returns (bool);\n\n    /// @notice Indicates the royalty policy for a given IP asset\n    /// @param ipId The ID of IP asset\n    /// @return royaltyPolicy The address of the royalty policy\n    function royaltyPolicies(address ipId) external view returns (address);\n\n    /// @notice Whitelist a royalty policy\n    /// @dev Enforced to be only callable by the protocol admin\n    /// @param royaltyPolicy The address of the royalty policy\n    /// @param allowed Indicates if the royalty policy is whitelisted or not\n    function whitelistRoyaltyPolicy(address royaltyPolicy, bool allowed) external;\n\n    /// @notice Whitelist a royalty token\n    /// @dev Enforced to be only callable by the protocol admin\n    /// @param token The token address\n    /// @param allowed Indicates if the token is whitelisted or not\n    function whitelistRoyaltyToken(address token, bool allowed) external;\n\n    /// @notice Executes royalty related logic on license minting\n    /// @dev Enforced to be only callable by LicensingModule\n    /// @param ipId The ipId whose license is being minted (licensor)\n    /// @param royaltyPolicy The royalty policy address of the license being minted\n    /// @param licenseData The license data custom to each the royalty policy\n    /// @param externalData The external data custom to each the royalty policy\n    function onLicenseMinting(\n        address ipId,\n        address royaltyPolicy,\n        bytes calldata licenseData,\n        bytes calldata externalData\n    ) external;\n\n    /// @notice Executes royalty related logic on linking to parents\n    /// @dev Enforced to be only callable by LicensingModule\n    /// @param ipId The children ipId that is being linked to parents\n    /// @param royaltyPolicy The common royalty policy address of all the licenses being burned\n    /// @param parentIpIds The parent ipIds that the children ipId is being linked to\n    /// @param licenseData The license data custom to each the royalty policy\n    /// @param externalData The external data custom to each the royalty policy\n    function onLinkToParents(\n        address ipId,\n        address royaltyPolicy,\n        address[] calldata parentIpIds,\n        bytes[] memory licenseData,\n        bytes calldata externalData\n    ) external;\n\n    /// @notice Allows the function caller to pay royalties to the receiver IP asset on behalf of the payer IP asset.\n    /// @param receiverIpId The ID of the IP asset that receives the royalties\n    /// @param payerIpId The ID of the IP asset that pays the royalties\n    /// @param token The token to use to pay the royalties\n    /// @param amount The amount to pay\n    function payRoyaltyOnBehalf(address receiverIpId, address payerIpId, address token, uint256 amount) external;\n\n    /// @notice Allows to pay the minting fee for a license\n    /// @param receiverIpId The ipId that receives the royalties\n    /// @param payerAddress The address that pays the royalties\n    /// @param licenseRoyaltyPolicy The royalty policy of the license being minted\n    /// @param token The token to use to pay the royalties\n    /// @param amount The amount to pay\n    function payLicenseMintingFee(\n        address receiverIpId,\n        address payerAddress,\n        address licenseRoyaltyPolicy,\n        address token,\n        uint256 amount\n    ) external;\n}\n"},"@openzeppelin/contracts/token/ERC1155/IERC1155.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"},"@openzeppelin/contracts/access/IAccessControl.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"},"@story-protocol/protocol-core/contracts/lib/registries/IPAccountChecker.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { IERC6551Account } from \"erc6551/interfaces/IERC6551Account.sol\";\n\nimport { IIPAccountRegistry } from \"../../interfaces/registries/IIPAccountRegistry.sol\";\nimport { IIPAccount } from \"../..//interfaces/IIPAccount.sol\";\n\n/// @title IPAccountChecker\n/// @dev This library provides utility functions to check the registration and validity of IP Accounts.\n/// It uses the ERC165 standard for contract introspection and the IIPAccountRegistry interface\n/// for account registration checks.\nlibrary IPAccountChecker {\n    /// @notice Returns true if the IPAccount is registered.\n    /// @param chainId_ The chain ID where the IP Account is located.\n    /// @param tokenContract_ The address of the token contract associated with the IP Account.\n    /// @param tokenId_ The ID of the token associated with the IP Account.\n    /// @return True if the IP Account is registered, false otherwise.\n    function isRegistered(\n        IIPAccountRegistry ipAccountRegistry_,\n        uint256 chainId_,\n        address tokenContract_,\n        uint256 tokenId_\n    ) external view returns (bool) {\n        return ipAccountRegistry_.ipAccount(chainId_, tokenContract_, tokenId_).code.length != 0;\n    }\n\n    /// @notice Checks if the given address is a valid IP Account.\n    /// @param ipAccountRegistry_ The IP Account registry contract.\n    /// @param ipAccountAddress_ The address to check.\n    /// @return True if the address is a valid IP Account, false otherwise.\n    function isIpAccount(\n        IIPAccountRegistry ipAccountRegistry_,\n        address ipAccountAddress_\n    ) external view returns (bool) {\n        if (ipAccountAddress_ == address(0)) return false;\n        if (ipAccountAddress_.code.length == 0) return false;\n        if (!ERC165Checker.supportsERC165(ipAccountAddress_)) return false;\n        if (!ERC165Checker.supportsInterface(ipAccountAddress_, type(IERC6551Account).interfaceId)) return false;\n        if (!ERC165Checker.supportsInterface(ipAccountAddress_, type(IIPAccount).interfaceId)) return false;\n        (uint chainId, address tokenContract, uint tokenId) = IIPAccount(payable(ipAccountAddress_)).token();\n        return ipAccountAddress_ == ipAccountRegistry_.ipAccount(chainId, tokenContract, tokenId);\n    }\n}\n"},"@story-protocol/protocol-core/contracts/interfaces/IAccessController.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\nimport { AccessPermission } from \"../lib/AccessPermission.sol\";\n\ninterface IAccessController {\n    /// @notice Emitted when a permission is set.\n    /// @param ipAccount The address of the IP account that grants the permission for `signer`\n    /// @param signer The address that can call `to` on behalf of the IP account\n    /// @param to The address that can be called by the `signer` (currently only modules can be `to`)\n    /// @param func The function selector of `to` that can be called by the `signer` on behalf of the `ipAccount`\n    /// @param permission The permission level\n    event PermissionSet(\n        address ipAccountOwner,\n        address indexed ipAccount,\n        address indexed signer,\n        address indexed to,\n        bytes4 func,\n        uint8 permission\n    );\n\n    /// @notice Sets a batch of permissions in a single transaction.\n    /// @dev This function allows setting multiple permissions at once. Pausable.\n    /// @param permissions An array of `Permission` structs, each representing the permission to be set.\n    function setBatchPermissions(AccessPermission.Permission[] memory permissions) external;\n\n    /// @notice Sets the permission for all IPAccounts\n    /// @dev Enforced to be only callable by the protocol admin in governance.\n    /// @param signer The address that can call `to` on behalf of the IP account\n    /// @param to The address that can be called by the `signer` (currently only modules can be `to`)\n    /// @param func The function selector of `to` that can be called by the `signer` on behalf of the `ipAccount`\n    /// @param permission The new permission level\n    function setGlobalPermission(address signer, address to, bytes4 func, uint8 permission) external;\n\n    /// @notice Sets the permission for a specific function call\n    /// @dev Each policy is represented as a mapping from an IP account address to a signer address to a recipient\n    /// address to a function selector to a permission level. The permission level can be 0 (ABSTAIN), 1 (ALLOW), or\n    /// 2 (DENY).\n    /// @dev By default, all policies are set to 0 (ABSTAIN), which means that the permission is not set.\n    /// The owner of ipAccount by default has all permission.\n    /// address(0) => wildcard\n    /// bytes4(0) => wildcard\n    /// Specific permission overrides wildcard permission.\n    /// @param ipAccount The address of the IP account that grants the permission for `signer`\n    /// @param signer The address that can call `to` on behalf of the `ipAccount`\n    /// @param to The address that can be called by the `signer` (currently only modules can be `to`)\n    /// @param func The function selector of `to` that can be called by the `signer` on behalf of the `ipAccount`\n    /// @param permission The new permission level\n    function setPermission(address ipAccount, address signer, address to, bytes4 func, uint8 permission) external;\n\n    /// @notice Checks the permission level for a specific function call. Reverts if permission is not granted.\n    /// Otherwise, the function is a noop.\n    /// @dev This function checks the permission level for a specific function call.\n    /// If a specific permission is set, it overrides the general (wildcard) permission.\n    /// If the current level permission is ABSTAIN, the final permission is determined by the upper level.\n    /// @param ipAccount The address of the IP account that grants the permission for `signer`\n    /// @param signer The address that can call `to` on behalf of the `ipAccount`\n    /// @param to The address that can be called by the `signer` (currently only modules can be `to`)\n    /// @param func The function selector of `to` that can be called by the `signer` on behalf of the `ipAccount`\n    function checkPermission(address ipAccount, address signer, address to, bytes4 func) external view;\n\n    /// @notice Returns the permission level for a specific function call.\n    /// @param ipAccount The address of the IP account that grants the permission for `signer`\n    /// @param signer The address that can call `to` on behalf of the `ipAccount`\n    /// @param to The address that can be called by the `signer` (currently only modules can be `to`)\n    /// @param func The function selector of `to` that can be called by the `signer` on behalf of the `ipAccount`\n    /// @return permission The current permission level for the function call on `to` by the `signer` for `ipAccount`\n    function getPermission(address ipAccount, address signer, address to, bytes4 func) external view returns (uint8);\n}\n"},"@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"},"@story-protocol/protocol-core/contracts/lib/AccessPermission.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.23;\n\n/// @title Access Permission Library\n/// @notice Library for IPAccount access control permissions.\n///         These permissions are used by the AccessController.\nlibrary AccessPermission {\n    /// @notice ABSTAIN means having not enough information to make decision at current level, deferred decision to up\n    /// level permission.\n    uint8 public constant ABSTAIN = 0;\n\n    /// @notice ALLOW means the permission is granted to transaction signer to call the function.\n    uint8 public constant ALLOW = 1;\n\n    /// @notice DENY means the permission is denied to transaction signer to call the function.\n    uint8 public constant DENY = 2;\n\n    /// @notice This struct is used to represent permissions in batch operations within the AccessController.\n    /// @param ipAccount The address of the IP account that grants the permission for `signer`\n    /// @param signer The address that can call `to` on behalf of the `ipAccount`\n    /// @param to The address that can be called by the `signer` (currently only modules can be `to`)\n    /// @param func The function selector of `to` that can be called by the `signer` on behalf of the `ipAccount`\n    /// @param permission The permission level for the transaction (0 = ABSTAIN, 1 = ALLOW, 2 = DENY).\n    struct Permission {\n        address ipAccount;\n        address signer;\n        address to;\n        bytes4 func;\n        uint8 permission;\n    }\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":20000},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}